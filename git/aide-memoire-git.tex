\documentclass[a4paper,twoside]{article}
\usepackage{autiwa}

\title{Aide mémoire Subversion (svn)}
\author{Autiwa}

\newcommand{\raccourci}[1]{{\bfseries #1}}

\makeindex
\begin{document}

\tableofcontents

\clearpage

\section{Préambule}
Git permet de gérer un projet (de programmation généralement) et de garder en mémoire l'historique de toutes les versions d'un ensemble de fichiers. Il permet de gérer un projet à plusieurs, de programmer afin de pouvoir revenir en arrière, comparer avec d'anciennes versions et cie. 

Le principe est d'avoir un serveur git (un seul possible) qui va garder en mémoire l'historique de toutes les versions et un client git (plusieurs possibles) qui vont se connecter au serveur pour mettre à jour la version des fichiers ou en récupérer les dernières versions.

\begin{remarque}
Il est possible que le serveur soit lui aussi client, dans le cas où il n'y aurait qu'un seul développeur et qu'on ne souhaite pas passer par internet.
\end{remarque}

\subsection{Configuration}
Afin d'avoir la coloration syntaxique, il faut faire : 
\begin{verbatim}
git config --global color.diff auto
git config --global color.status auto
git config --global color.branch auto
\end{verbatim}

De même, il faut configurer votre nom (ou pseudo) :
\begin{verbatim}
git config --global user.name "votre_pseudo"
\end{verbatim}


Puis votre e-mail :
\begin{verbatim}
git config --global user.email moi@email.com
\end{verbatim}


Vous pouvez aussi éditer votre fichier de configuration .gitconfig situé dans votre répertoire personnel pour y ajouter une section alias à la fin :
\begin{verbatim}
vim ~/.gitconfig
\end{verbatim}

\begin{verbatim}
[color]
        diff = auto
        status = auto
        branch = auto
[user]
        name = votre_pseudo
        email = moi@email.com
[alias]
        ci = commit
        co = checkout
        st = status
        br = branch
\end{verbatim}

\section{Commandes universelles git}
Ici, je note les commandes qui sont valables à la fois pour svn installé sur un serveur internet, ou sur une machine locale pour un usage personnel

\subsection{Mettre à jour sa copie locale : pull}\index{commande git!pull} \index{Mise à jour du dépôt}
\begin{verbatim}
git pull
\end{verbatim}

Pour celà, il faut que le dossier dans lequel on se trouve ait déjà été défini comme un dossier git via un \gras[commande git!clone]{clone} (voir \refsec{sec:checkout})

\subsection{Lister les modifications locales}\index{git!status}
La commande git status vous indique les fichiers que vous avez modifiés récemment :
\begin{verbatim}
$ git status
# On branch master
nothing to commit (working directory clean)
\end{verbatim}

\subsection{Ajouter des fichiers ou dossiers au projet : add}\index{commande git!add} \index{Ajouter des fichiers}
Pour ajouter des fichiers il faut faire :
\begin{verbatim}
git add latex/ vim/ 
\end{verbatim}
où \textbf{latex/} et \textbf{vim/} sont deux dossiers existant dans le dossier local de référence

\begin{remarque}
Au cas où ça serait pas clair. J'ai créé un dossier \textbf{/home/autiwa/Formulaires} grâce à \refsec{sec:checkout}. Dans ce dossier, j'ai créé et rempli à la main les sous-dossiers \textbf{latex/} et \textbf{vim/}. Maintenant, grâce à la commande ci-dessus, je définis ces sous-dossiers comme étant rattachés au projet. En faisant ainsi le contenu est rajouté récursivement.
\end{remarque}

\begin{attention}
Cette commande n'agit que sur le répertoire local (la \emph{working copy}). Il faut ensuite appliquer ces changements au dépot (voir \refsec{sec:commit}) pour les valider.
\end{attention}

\subsection{Voir les différences entre la version du serveur et la version locale}

\begin{verbatim}
git diff
\end{verbatim}

\begin{remarque}
Il est possible de regarder les différences sur un fichier en particulier.
\end{remarque}

\subsection{Enregistrer les modifications localement : commit}\index{commande git!commit}\index{mise à jour local -> serveur}\label{sec:commit}

Pour mettre à jour les versions sur serveur à partir des modifications effectuées localement, il faut : 
\begin{verbatim}
git commit -a -m "initialisation"
\end{verbatim}
où \textbf{"initialisation"} est le commentaire qui décrit la mise à jour et les modifications effectuées. 

\begin{attention}
Un commit avec git est local : à moins d’envoyer ce commit sur le serveur comme on apprendra à le faire plus loin, personne ne sait que vous avez fait ce commit pour le moment. Cela a un avantage : si vous vous rendez compte que vous avez fait une erreur dans votre dernier commit, vous avez la possibilité de l’annuler (ce qui n’est pas le cas avec SVN !).
\end{attention}

On peut modifier ces commits là, tant qu'ils sont en local. Puis une fois vérifié. Il ne reste plus qu'à les envoyer sur le serveur. Pour celà on vérifie tout d'abord ce qu'on s'apprête à envoyer, et on envoie sur le serveur : 
\begin{verbatim}
git log -p
git push
\end{verbatim}

\subsection{Annuler un commit effectué par erreur}
%TODO


\section{Git sur internet}
Je vais prendre l'exemple de google code, qui est celui que j'ai choisi et que je suis en train d'apprendre.

\subsection{Récupérer le contenu du projet}\label{sec:checkout}
Une fois le projet créé (sur la page \url{http://code.google.com/hosting/createProject}), il faut faire : 
\begin{verbatim}
cd Formulaire
git clone https://autiwa@code.google.com/p/autiwa-tutorials/ 
\end{verbatim}\index{commande git!clone}

Cette commande permet de récupérer le contenu du projet et de le copier dans un dossier \textbf{Formulaires} qui sera créé dans le dossier courant.

\begin{definition}[Clone]
Opération d'extraction d'une version d'un projet du repository vers un répertoire de travail local.
\end{definition}


\section{Git localement}
Le serveur ET le client seront alors sur la même machine.

\subsection{Création du projet}
J'ai créé un dossier \textbf{mercury} dans mon \textbf{\$HOME}, puis je fais, dans mon répertoire utilisateur : 
\begin{verbatim}
cd mercury
git init
\end{verbatim}
pour un projet que j'appelle \textbf{mercury}.


\section{Gérer un conflit}
%TODO


\printindex
\end{document}