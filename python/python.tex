\documentclass[a4paper,twoside]{article}
\usepackage{autiwa}
\title{}
\author{Autiwa}
\makeindex
\usepackage{color}
\definecolor{gray}{gray}{0.5}
\definecolor{green}{rgb}{0,0.5,0}

\lstnewenvironment{python}[1][]{
\lstset{
language=python,
basicstyle=\ttfamily\small\setstretch{1},
stringstyle=\color{red},
showstringspaces=false,
alsoletter={1234567890},
otherkeywords={\ , \}, \{},
keywordstyle=\color{blue},
emph={access,and,break,class,continue,def,del,elif,else,%
except,exec,finally,for,from,global,if,import,in,is,%
lambda,not,or,pass,print,raise,return,try,while},
emphstyle=\color{black}\bfseries,
emph={[2]True, False, None, self},
emphstyle=[2]\color{green},
emph={[3]from, import, as},
emphstyle=[3]\color{blue},
upquote=true,
morecomment=[s]{"""}{"""},
commentstyle=\color{gray}\slshape,
emph={[4]1, 2, 3, 4, 5, 6, 7, 8, 9, 0},
emphstyle=[4]\color{blue},
literate=*{:}{{\textcolor{blue}:}}{1}%
	{=}{{\textcolor{blue}=}}{1}%
	{-}{{\textcolor{blue}-}}{1}%
	{+}{{\textcolor{blue}+}}{1}%
	{*}{{\textcolor{blue}*}}{1}%
	{!}{{\textcolor{blue}!}}{1}%
	{(}{{\textcolor{blue}(}}{1}%
	{)}{{\textcolor{blue})}}{1}%
	{[}{{\textcolor{blue}[}}{1}%
	{]}{{\textcolor{blue}]}}{1}%
	{<}{{\textcolor{blue}<}}{1}%
	{>}{{\textcolor{blue}>}}{1},%
framexleftmargin=1mm, framextopmargin=1mm, frame=shadowbox, rulesepcolor=\color{blue},#1
}}{}


\begin{document}
\tableofcontents

\clearpage
Soit on lance l'interpréteur via \verb|python|, soit on exécute un script python, qui doit commencer par les lignes suivantes
\begin{verbatim}
#!/usr/bin/env python
# -*- coding: utf-8 -*-
\end{verbatim}

La première ligne pour définir que c'est un script python et la deuxième pour spécifier l'encodage du script (pour moi, utf-8).

\section{Pour débuter}
En python, la mise en forme du code est primordiale puisque c'est elle qui détermine comment il est exécuté. Il est conseillé d'utiliser une indentation de 4 espaces (de n'utiliser que des espaces ou que des tabulations, mais une préférences pour les espaces, ne me demandez pas pourquoi\dots)

\subsection{Boucles}\index{boucles}
Pour effectuer une boucle, on fera donc
\begin{verbatim}
for i in range(5):
  print i
print "ici, on n'est plus dans la boucle"
\end{verbatim}

\begin{verbatim}
list = ['a', 'b', 'c', 'd']
for ele in list:
  print ele
\end{verbatim}

\begin{verbatim}
a = 0
while (a<1):
  print a
  a += 1
\end{verbatim}

\begin{verbatim}
a = 0
if (a==0):
  print "a est nul"
elif a==1:
  print "a vaut 1"
else:
  print "a ne vaut ni 0 ni 1"
# fin de la boucle
\end{verbatim}

\begin{table}[htb]
\begin{tabular}{>{\bfseries}r<{}@{ : }p{11cm}}
Opérateur &	effet\\
a == b & teste si a et b sont égaux\\
a > b & teste si a est strictement supérieur à b\\
a < b & teste si a est strictement inférieur à b\\
a >= b & teste si a est supérieur ou égal à b\\
a <= b & teste si a est inférieur ou égal à b\\
a != b & teste si a et b sont différent
\end{tabular}
\caption{Quelques opérateurs de comparaison en python. Ils renvoient des expressions booléennes. On peut aussi combiner plusieurs tests à l'aide de \texttt{and} et \texttt{or}.}
\end{table}


\begin{remarque}
À noter les fonction \texttt{continue} et \texttt{break} à utiliser dans des boucles. \texttt{continue} permet de sauter la boucle actuelle pour passer à l'itération suivante. \texttt{break}, quant à lui, permet d'arrêter la boucle avant sa fin.
\end{remarque}



\subsection{Variables et types numériques}

La fonction \gras[python!type]{type} permet de connaître le type d'une variable.
\begin{verbatim}
a = 2
b = 2.
c = 'chaine'
type(a), type(b), type(c)
\end{verbatim}

Pour limiter le nombre de chiffres significatifs d'un réel, il faut utiliser la fonction \texttt{round(x,n)} qui arrondit la variable x avec n chiffres après la virgule.
\begin{verbatim}
>>> round(1.23441, 2)
1.23
\end{verbatim}

Une fonction très pratique est la fonction \texttt{eval}. Elle permet de dire à python de considérer le contenu d'une variable ou expression comme si c'était du code python. Un exemple concrêt :
\begin{verbatim}
a = 2
b = 'a'
print eval(b)
\end{verbatim}

On voit rapidement les possibilités de cette commande dans des boucles et autres joyeusetées.

\bigskip

Il existe en python le type booléen dont les valeurs possibles sont \texttt{True} ou \texttt{False}
\begin{verbatim}
a = True
if a:
  print a
a = False
if not(a):
  print "C'est faux"
\end{verbatim}

\subsection{Débug}
Pour celà, il existe le module \gras[module!pdb]{pdb} qui sert à ça.

On l'importe de la façon suivante
\begin{verbatim}
import pdb
\end{verbatim}

La commande utile, si on ne doit en retenir qu'une est :
\begin{verbatim}
pdb.set_trace()
\end{verbatim}

Cette commande stoppe le programme et donne la main à l'interpréteur, nous permettant de regarder l'état des variables. Il permet aussi de continuer le programme ligne à ligne, mais je sais pas encore comment.

Ensuite, on peut taper des commandes python, notamment pour évaluer les variables. Mais il existe aussi des commandes propres au débuguage donc voici une liste des plus utiles :
\begin{itemize}
\item[s] continue l'exécution et s'arrête dès que possible (en gros, si tout va bien, s'arrête à la ligne suivante)
\item[r] continue l'exécution jusqu'à la fin de la fonction en cours (s'arrête juste avant le return s'il y en a un il me semble)
\end{itemize}
Sinon, pour quitter, \touche{Ctrl}+\touche{C}, ou \texttt{exit()}

\section{Fonctions}
On peut bien évidemment créer des fonctions en python. Une fonction très simple serait
\begin{verbatim}
def affiche(variable):
  print variable
\end{verbatim}
qui se contenterait d'afficher le contenu de la variable passée en argument.

Une fonction peut retourner des valeurs via \verb|return variable|. Cette fonction peut renvoyer plusieurs valeurs, on aura donc :
\begin{verbatim}
def produit_somme(a,b):
  somme = a + b
  produit = a * b
  return somme, produit_somme

(sum_ab, prod_ab) = produit_somme(2,3)
\end{verbatim}

On peut aussi avoir des paramètres optionnels, à qui on donne une valeur par défaut :
\begin{verbatim}
def test(a, b=3)
  print a*b
\end{verbatim}

On peut aussi gérer un nombre inconnu de variable :
\begin{verbatim}
def test(*args):
  for arg in args:
    print arg
test('coucou', 2, 1, range(2))
test('coucou', 2)
\end{verbatim}

Ceci peut s'ajouter à d'autres variables, elles obligatoires :
\begin{verbatim}
def test(nom, *variables):
  print nom
  for var in variables:
    print var
test('coucou', 2, 1, range(2))
test('coucou', 2)
\end{verbatim}

\subsection{Documenter une fonction}
\source{tuto de suzy}

Une dernière chose très importante lorsque vous définissez une fonction, c'est sa documentation ! Vous allez commencer à documenter votre code pour le rendre plus compréhensible et exploitable par d'autres personnes que vous. Pour cela, c'est très simple, il suffit de placer immédiatement sous la ligne de définition de votre fonction, une chaîne de caractères entre triple 'quote' (""" ou ''') qui sera considérée un commentaire.

\begin{verbatim}
def fonction(arg1, arg2) :
    """
    Je documente ma fonction. J'explique rapidement à quoi sert cette fonction.
    arg1 : J'écris à quoi correspond cet argument.
    arg2 : J'écris à quoi correspond cet argument.
    return : J'indique ce que retourne la fonction
    """
    pass
\end{verbatim}

Voici un exemple d'une manière simple de documenter clairement vos fonctions. Il faut au minimum expliquer ce que fait la fonction. Une documentation complète détaille aussi le sens de chacun des arguments et ce que retourne la fonction. Avec une bonne documentation, personne ne doit avoir besoin de lire le code pour comprendre à quoi sert la fonction et ce qu'elle fait. Cela permet de la conserver en tant que boîte noire qui ne regarde que celui qui l'a implémentée.

\begin{remarque}
Le mot clé \gras{pass} vous permet de sortir d'une structure. Il peut être utile par exemple lorsque vous développez un projet. Une bonne technique de développement étant de définir les fonctions puis l'algorithme principal et enfin d'implémenter les fonctions. Ce mot clé vous permet donc d'avoir toutes vos fonctions définies sans avoir à les implémenter à l'avance.
\end{remarque}

\subsection{Passer plusieurs arguments d'une fonction à l'aide d'une séquence}\label{sec:args_liste}
Il est tout à fait possible de passer pour ce type d'argument une séquence, pour cela, il suffit de la faire précéder d'une étoile pour la convertir.

\begin{verbatim}
def fonction(*arguments) :
    """Test de fonction avec un nombre indéfini d'arguments.
    arguments : Une séquence à écrire en console."""
    for element in arguments :
        print(element)

fonction(*'abcdef')
\end{verbatim}

Si vous n'utilisez pas l'opérateur '*', votre séquence sera alors considérée comme n'étant qu'un seul argument ! Cela est dû au typage dynamique. En effet, n'importe quel argument de votre fonction peut prendre n'importe quel type, il faut donc préciser ici que chaque élément de la séquence est un argument à part entière.

\subsection{Nombre indéfini d'arguments}
\source{tuto de suzy}

Il existe des fonctions qui acceptent un nombre indéterminé d'arguments, c'est le cas de la fonction print par exemple. Comment cela fonctionne-t-il ? Et bien, c'est assez simple. Pour cela, il est possible de le faire de deux manières : avec des arguments anonymes ou avec arguments associés à des clés. Nous allons donc voir les deux manières de créer des fonctions avec un nombre indéterminé de paramètres.

\subsubsection{Arguments anonymes}

La syntaxe est particulièrement simple. En fait, vous allez préciser une séquence (liste, tuple ou chaîne de caractères) comme argument. Le fait que cet argument doivent être une séquence se précise par l'utilisation de l'opérateur '*' juste avant le nom de l'argument :

\begin{verbatim}
def fonction(*arguments) :
    """Test de fonction avec un nombre indéfini d'arguments.
    arguments : Une séquence à écrire en console."""
    for element in arguments :
        print(element)

fonction(43, 38, "Peuh !", True)
\end{verbatim}

De cette façon, il est donc possible d'appeler ma fonction avec un nombre indéfini d'arguments mais attention, cela est possible à une seule condition : la séquence d'arguments doit impérativement se situer en dernier argument de la fonction ! Les arguments s'écrivent donc dans l'ordre suivant dans la déclaration d'une fonction : les arguments obligatoires, les arguments avec valeur par défaut (facultatifs) et enfin des arguments supplémentaires si nécessaires.

En utilisant l'astuce \refsec{sec:args_liste} ça donne :
\begin{verbatim}
def fonction(*arguments) :
    """Test de fonction avec un nombre indéfini d'arguments.
    arguments : Une séquence à écrire en console."""
    for element in arguments :
        print(element)

fonction(*'abcdef')
\end{verbatim}

\subsubsection{Arguments avec clé}

Si vous voulez associer une clé à chacun des arguments que vous donnez en supplément à une fonction, il va falloir utiliser un dictionnaire. Et ce coup-ci, c'est l'opérateur '**' qui sera utilisé.

\begin{verbatim}
def fonction(**arguments) :
    """Test de fonction avec un nombre indéfini d'arguments.
    arguments : Un dictionnaire à écrire en console."""
    for cle in arguments :
        print(cle,arguments[cle])

fonction(arg1 = 'Peuh !', arg2 = 38)
\end{verbatim}

Vous verrez en exécutant ce code que l'on peut donc facilement créer des couples (clé,valeur) à passer en paramètre. La contrainte est la même que précédemment et le dictionnaire d'arguments doit être impérativement placé en dernier dans la liste d'arguments lors de la déclaration de la fonction. Encore une fois, pour convertir un dictionnaire non pas un seul argument mais en une suite d'arguments, il faut utiliser l'opérateur '**' devant le dictionnaire passé en argument.

\begin{verbatim}
def fonction(**arguments) :
    """Test de fonction avec un nombre indéfini d'arguments.
    arguments : Un dictionnaire à écrire en console."""
    for cle in arguments :
        print(cle,arguments[cle])

fonction(**dict(arg1 = 'Peuh !', arg2 = 38))
\end{verbatim}

\subsection{Importer des fonctions}\label{sec:importer_fonctions}\index{importer des modules}
On peut importer des fonctions très facilement. Il convient pourtant de prendre de bonnes habitudes dès le départ. Par exemple, pour importer la fonction \texttt{sin()}, on peut choisir une des lignes suivantes :
\begin{verbatim}
import math
from math import *
from math import sin
import math as m
\end{verbatim}

Ceci est donné uniquement à titre d'exemple. La première ligne importe toute la librairie math, et pour appeler la fonction sinus, il faudra faire \texttt{math.sin(x)}

Dans le cas de la deuxième ligne, on pourra faire  \texttt{sin(x)}

La 3\ieme ligne est identique à la 2\ieme à ceci près qu'elle n'importe que la fonction sinus, et pas les autres fonctions de la librairie math. Ça permet de gagner un peu de place en n'important que ce dont on a besoin.

La 4\ieme et dernière ligne importe toute la librairie math et définit un alias à celle ci. Ainsi, pour appeler la fonction sinus, on fera \texttt{m.sin(x)}.

\bigskip

Maintenant, voici ce qu'il faut éviter de faire : Il ne faut pas utiliser les lignes 2 ou 3 qui nous font perdre l'information d'où provient la fonction qu'on utilise.

Personnellement, je continue à le faire pour la librairie math, mais c'est la seule exception. Par exemple pour les plots, j'utilise \gras{pylab} via
\begin{verbatim}
import pylab as pl
\end{verbatim}
Ce qui fait que quand j'utilise une fonction via \texttt{pl.nomdefonction()} je sais qu'elle provient de la librairie pylab.

L'autre avantage de cette méthode est qu'elle permet d'éviter les conflits entre deux fonctions qui auraient le même nom, et provenant de librairies différentes\footnote{Par exemple la librairie pylab définit d'autres fonction trigonométriques (\texttt{sin()}, \dots)}.

Enfin le dernier avantage, et non le moindre, est qu'en important via \texttt{import \emph{module}} ou \texttt{import \emph{module} as \emph{alias}}, ne seront chargé en mémoire que les fonctions effectivement utilisées.

\begin{attention}
Avec \texttt{from \emph{module} import *}, on importe absolument tout, y compris les variables qui pourraient être définies. C'est donc à éviter, sauf cas particulier.
\end{attention}





\section{Manipuler des fichiers}\index{fichier!lire}\index{fichier!écrire}
%TODO parler des fichiers, écrire, fermer. Parler aussi des chaînes de caractère.

Pour manipuler un fichier, il faut dans un premier temps l'ouvrir (et spécifier si on veut pouvoir écrire, lire, ou écrire sans effacer le fichier au moment de l'ouverture), puis effectuer diverses opérations dans un second temps et enfin le fermer.

\begin{verbatim}
fichier = open("fichier.txt",'w')
fichier.write("ligne 1\nligne 2")
fichier.close()
\end{verbatim}
\verb|'w'| signifie que l'on souhaite écrire dans le fichier. Il signifie aussi que le fichier sera effacé lors de l'ouverture (au cas où le fichier existe). Si on ne souhaite pas effacer le fichier, il faut utiliser \verb|'a'| qui va permettre d'écrire à la suite du fichier.

Par exemple, voici la fonction que j'utilise pour écrire un fichier log de mon script.

\begin{verbatim}
def writelog(texte_log)
  log = open(nom_fichier_log,'a')
  log.write("["+str(time.strftime('%d/%m/%Y' %H:%M:%S'))+"] "+texte_log+"\n")
  log.close()
\end{verbatim}
(cette fonction ne retourne rien vu qu'il n'y en a pas besoin. Au début, je mettais \verb|return 0| mais pour l'instant je l'ai enlevé).

\bigskip

Pour lire un fichier, on procède de la manière suivante
\begin{verbatim}
fichier = open("fichier.txt",'r')
t = fichier.readlines()
fichier.close()
\end{verbatim}

Le fichier $t$ est une liste comprenant un élément pour chaque ligne du fichier lu. \texttt{fichier.readline()} ne lit qu'une seule ligne à la fois. \texttt{fichier.read(nb)} permet de lire \texttt{nb} caractères à partir de là où s'était arrêté la lecture.

\begin{remarque}
À noter que chaque ligne se termine par \verb|\n|.
\end{remarque}

\section{Modules}
Pour les commandes basiques d'importations, se reporter à \refsec{sec:importer_fonctions}.

\subsection{Importer des modules qui ne sont pas dans le répertoire courant.}\index{importer des modules}
En ajoutant
\begin{verbatim}
import sys
sys.path.append(monchemin)
\end{verbatim}
on peut spécifier un nouveau chemin pour un répertoire contenant des modules. Ainsi, python vérifiera dans ce dossier si le module qu'on souhaite importer s'y trouve (en plus des autres répertoires définis automatiquement et du répertoire courant)

\bigskip

Depuis Python 2.5, il est également possible d'effectuer des importations relatives. Pour cela, il vous faut d'abord créer un fichier \verb|__init__.py| dans le répertoire contenant les modules à importer. Ce fichier peut être vide. Par exemple, considérons un répertoire locale qui contient un répertoire \texttt{A} lui même contenant un fichier \verb|__init__.py| vide et un fichier \texttt{testA.py}. Depuis votre répertoire local, vous pouvez importer \texttt{testA} par l'instruction \texttt{import A.testA}, \texttt{from A import testA} ou \texttt{from A.testA import *}.

\subsection{subprocess}\label{sec:subprocess}\index{subprocess}
Pour lancer une commande dans un processus séparé on fait :
\begin{verbatim}
process = subprocess.Popen("ls")
\end{verbatim}

Il y a en pratique deux techniques. Où bien on lance la commande et les arguments en séparant :
\begin{verbatim}
process = subprocess.Popen(["ls", "-l"])
\end{verbatim}
ou bien on lance une chaîne de caractère, et dans ce cas, on spécifie que c'est ce qu'on veut exécuter dans le terminal
\begin{verbatim}
process = subprocess.Popen("ls -l", shell=True)
\end{verbatim}

\bigskip

Pour récupérer la sortie de la commande, on y accès via
\begin{verbatim}
sortie = process.stdout.readlines()
\end{verbatim}
à condition d'avoir lancé le script avec l'option \verb|stdout=subprocess.PIPE| ; dans le cas de l'exemple précédent, ça donne donc :
\begin{verbatim}
process = subprocess.Popen("ls -l", shell=True, stdout=subprocess.PIPE)
sortie = process.stdout.readlines()
print sortie
\end{verbatim}

\begin{remarque}
\verb|sortie| est donc un objet-fichier (la même chose que si on avait fait \texttt{sortie = open("fichier.txt", 'r')}).
\end{remarque}


Sinon, on peut écrire la sortie dans un fichier de la façon suivante :
\begin{verbatim}
sortie = open("sortie.txt", 'w')
process = subprocess.Popen("ls -l", shell=True, stdout=sortie)
sortie.close()
\end{verbatim}

Pour que le script attende la fin du processus avant de continuer, on fait
\begin{verbatim}
fail = process.wait()
\end{verbatim}
à quoi on peut rajouter un
\begin{verbatim}
if (fail==0):
  print "OK"
else:
  print "fail"
\end{verbatim}









\section{Tout savoir sur les listes}\index{liste}
On définit une liste de la façon suivante :
\begin{verbatim}
a = [1.2, 2.3, 4.1, 5.7]
\end{verbatim}

On peut appeler un élément à l'aide de crochets. On aura
\begin{verbatim}
a[0] = 1.2
a[-1] = a[3] = 5.7
a[-2] = a[2] = 4.1
\end{verbatim}

On peut rajouter un élément à la liste via
\begin{verbatim}
a.append(6.8)
\end{verbatim}
On aura alors
\begin{verbatim}
a = [1.2, 2.3, 4.1, 5.7, 6.8]
\end{verbatim}

pour avoir le nombre d'éléments de la liste, il suffit de faire
\begin{verbatim}
nb = len(a)
\end{verbatim}

Pour supprimer d'une liste les $n$ premiers éléments et les $m$ derniers, on fera
\begin{verbatim}
for indice in range(n):
  del(liste[0])

for indice in range(m):
  del(liste[-1])
\end{verbatim}

Pour récupérer l'indice d'une certaine valeur dans une liste :
\begin{verbatim}
>>> a.index(2.3)
1
\end{verbatim}


\bigskip

Il existe aussi les fonctions \gras{map} et \gras{zip} qui ont le même principe que sous Maple.

La fonction \gras{zip} retourne une liste de tuples
\begin{verbatim}
>>> print zip(['a', 'b', 'c'], [1, 2, 3])
[''a', a), ('b', 2), ('c', 3)]
\end{verbatim}

\begin{remarque}
Ça marche aussi avec plusieurs séquences. Les chaînes de caractères sont considérées comme des séquences, on peut donc les zipper aussi.

À noter que la sortie de la commande sera de la même longueur que la liste la plus courte passée en arguments.
\end{remarque}

La fonction \gras{map} applique une fonction à chaque élément de la séquence passée en argument.

\begin{verbatim}
>>> print map(abs, [-5, -7, -12])
[5, 7, 12]
\end{verbatim}
qui est l'équivalent de
\begin{verbatim}
>>> print [abs(i) for i in [-5, -7, -12]]
[5, 7, 12]
\end{verbatim}
à part le fait que \gras{map} est plus rapide.

Il est possible d'utiliser sa propre fonction. Il est possible d'utiliser une fonction qui nécessite plusieurs arguments, et de passer plusieurs listes à la fonction \gras{map}.
\begin{verbatim}
>>> print map(max, [4, 5, 6], [1, 2, 9])
[4, 5, 9]
\end{verbatim}

\bigskip

Il est possible de convertir une liste en tuple via la commande \texttt{tuple}
\begin{verbatim}
>>> a = [1, 2, 3]
>>> tuple(a)
(1, 2, 3)
\end{verbatim}


\subsection{List-comprehension}\index{list-comprehension}
Cette technique permet d'agir sur les listes très simplement et très rapidement. Dans bien des cas (pour ne pas dire tous), cette méthode sera plus rapide que l'équivalent avec une boucle :
\begin{verbatim}
list2 = [element * 2 for element in list]
list3 = [element + 3 for element in list if element>3]
\end{verbatim}

\subsection{Array et Numpy}\index{numpy}\index{array}\index{matrice}
\begin{verbatim}
import numpy as np
\end{verbatim}

Permet de multiplier terme à terme des matrices de manière très simple. On définit une matrice paragraph
\begin{verbatim}
m = np.array([[1, 2, 3], [4, 5, 6]])
\end{verbatim}

Après avoir galéré pendant plusieurs heures pour créer et remplir une matrice au fur et à mesure, j'ai trouvé plus pratique de définir une liste comme on le souhaite, avec la souplesse que l'on connait de Python, puis convertir cette liste en array pour faire les calculs.

\bigskip

Dans la suite, on considère une matrice \texttt{m}. On effectue la somme de tous les éléments de la matrice par
\begin{verbatim}
>>> m.sum()
21
\end{verbatim}

Pour effectuer la somme des éléments colonne par colonne (on somme donc sur l'indice des lignes, c'est à dire le premier indice) :
\begin{verbatim}
>>> m.sum(axis=0)
array([5, 7, 9])
\end{verbatim}

La même chose ligne par ligne (on somme donc sur les colonnes avec le numéro de ligne fixé) :
\begin{verbatim}
>>> m.sum(axis=1)
array([ 6, 15])
\end{verbatim}

\begin{remarque}
Apparemment, il existe \texttt{np.append(array, truc-à-rajouter, options)} qui permet de rajouter un truc à un array, et notamment de spécifier si on veut en ligne ou en colonne. Le truc c'est qu'apparemment, il reconstruit la matrice à chaque fois, donc pas sur qu'on gagne en temps d'exécution.
\end{remarque}

\texttt{np.zeros()} et \texttt{np.empty()} permettent de définir des matrices en spécifiant leur taille
\begin{verbatim}
np.zeros((2,3))
\end{verbatim}

Il est possible (et c'est très pratique) de définir une matrice de la même taille qu'une autre, en spécifiant qu'on ne souhaite que des 0 ou une matrice vide. Pour celà, on utilise
\begin{verbatim}
np.zeros_like(m)
np.empty_like(m)
\end{verbatim}

\subsubsection{Manipulation des array}
On peut sélectionner les valeurs répondant à un ou plusieurs critères avec :
\begin{verbatim}
a[a<2.]
a[(a<10) & (a>2)]
\end{verbatim}

Ces tests suppriment automatiquement les valeurs 'nan' qui ne vérifient aucun test. Si on veut juste supprimer les 'nan', on peut faire :
\begin{verbatim}
a[np.isfinite(a)]
\end{verbatim}



\section{Programmation objet}
\subsection{Les fonctions sont des objets}
Voici une astuce pour choisir une fonction en fonction de la valeur d'un paramètre, ceci de façon rapide et lisible :
\begin{verbatim}
def function1():
    print 'You chose one.'
def  function2():
    print 'You chose two.'
def  function3():
    print 'You chose three.'
#
# switch est notre dictionnaire de functions
switch = {
    'one': function1,
    'two': function2,
    'three': function3,
    }
#
# le choix peut être 'one', 'two', or 'three'
choice = raw_input('Enter one, two, or three :')
#
# call one of the functions
try:
    result = switch[choice]
except KeyError:
    print 'I didn\'t understand your choice.'
else:
    result()
\end{verbatim}

\verb|result = switch[choice]| est la ligne qui réalise le gros du travail. \verb|switch[choice]| renvoie un de nos objets fonctions (ou lève une \verb|KeyError|). Ensuite nous exécutons \verb|result()| qui l’appelle.

On peut économiser quelques lignes de code via :
\begin{verbatim}
# appelle une des fonctions
try:
    switch[choice]()
except KeyError:
    print 'I didn\'t understand your choice.'
\end{verbatim}


\section{Faire des graphiques}\index{graphiques}
\subsection{Graphiques 2D}
J'utilise le module \gras[module!pylab]{pylab} que j'importe par
\begin{verbatim}
import pylab as pl
\end{verbatim}

\begin{remarque}
\gras[module!pylab]{pylab} fonctionne comme les plots dans \gras{matlab}. Il existe aussi la possibilité de faire des subplots.

\begin{verbatim}
pl.figure(1)

# en haut a gauche
pl.subplot(221)
pl.plot(x,y)

#en haut a droite
pl.subplot(222)
pl.plot(x,y)

#en bas a gauche
pl.subplot(223)
pl.plot(x,y)

#en bas a droite
pl.subplot(224)
pl.plot(x,y)

pl.show()
\end{verbatim}

\end{remarque}


Pour faire un plot
\begin{verbatim}
pl.plot(x,y)
\end{verbatim}
l'enregistrer
\begin{verbatim}
pl.savefig('ma_figure.png')
pl.savefig('ma_figure.svg')
pl.savefig('ma_figure.pdf')
\end{verbatim}
l'afficher à l'écran
\begin{verbatim}
pl.show()
\end{verbatim}

Pour aller un peu plus loin
\begin{verbatim}
pl.figure(1) # Pour spécifier que la figure active est la 1
pl.clf()#pour remettre à zéro la figure active
pl.grid(True)
pl.xlabel("abscisse")
pl.ylabel("ordonnee")
pl.plot(x,y, 'r.', label="y=f(x)")
pl.plot(x,z, 'b-', label="z=g(x)")
pl.legend()#afficher la légende
pl.show()
\end{verbatim}

À la place de \verb|plot| on peut aussi faire :
\begin{verbatim}
pl.semilogx(x,y)
pl.semilogy(x,y)
pl.loglog(x,y)
pl.hist(x)
pl.hist([x,y])#pour afficher plusieurs histogrammes à la fois
\end{verbatim}

Pour spécifier le zoom sur la figure, il faut rajouter :
\begin{verbatim}
pl.axis([xmin, xmax, ymin, ymax])
\end{verbatim}

\subsubsection{Histogrammes}
\begin{verbatim}
pl.hist(x, normed=True, bins=20)
pl.hist([x,y], normed=True, bins=20, label=['x', 'y'])
\end{verbatim}

On peut changer le style avec \verb|histtype='style'| où \verb|style| peut prendre les valeurs suivantes :
\begin{itemize}
\item bar
\item barstacked
\item step
\item stepfilled
\end{itemize}

D'autres options pratiques sont :
\begin{verbatim}
cumulative=True
normed=True
bins=20
\end{verbatim}

\begin{attention}
Quand on veut afficher plusieurs histogrammes dans le même plots en plusieurs fois, il faut spécifier un range de bins bien définis. J'ai déjà fait deux groupes de deux histogrammes, et j'avais de gros soucis dans les valeurs, ceci dû à ces bins qui affichaient les mêmes valeurs mais qui au final ne correspondaient pas aux mêmes choses.
\end{attention}


\subsection{Graphiques plus évolués}
On peut afficher une matrice et spécifier des axes (par défaut, il n'affiche que les indices de la matrices, mais on peut associer des plages de valeurs arbitraires aux axes x et y)

\begin{verbatim}
liste_x = range(5)
liste_y = range(5)
pl.figure(1)
pl.xlabel("axe des x")
pl.ylabel("axe des y")
import pylab as pl
pl.matshow(matrice, fignum=1)
pl.colorbar()
axes = pl.gca()
axes.set_xticks(range(len(liste_x)))
axes.set_xticklabels(liste_x)
axes.set_yticks(range(len(liste_y)))
axes.set_yticklabels(liste_y)
pl.show()
\end{verbatim}

\section{Faire des statistiques}
\subsection{Bases}
Dans \gras{numpy}, il existe les fonctions statistiques de bases, notamment la \gras[moyenne]{valeur moyenne} et l'\gras{écart-type} :
\begin{verbatim}
a = range(10)
np.mean(a)
np.std(a)
\end{verbatim}



\subsection{Test de Kolmogorov-Smirnov}
Pour celà, il faut utiliser le module suivant :
\begin{verbatim}
import scipy.stats.stats as scss
\end{verbatim}
et on appelle le test via
\begin{verbatim}
(d_value, p_value) = scss.ks_2samp(a,b)
\end{verbatim}
où $a$ et $b$ sont deux échantillons de données (des listes ou des array quoi).





\section{Exécuter des commandes système}
%TODO parler de os et commands (notamment getoutput et system)
Le module \gras[python!os]{os} permet d'utiliser plusieurs commandes systèmes dont voici quelques équivalents

\begin{tabular}{>{\bfseries}r<{}@{ : }p{11cm}}
commande bash & équivalent python\\
cd 'dossier' & os.chdir('nom dossier')\\
mkdir & os.mkdir('dossier')\\
ls & os.listdir('.')\\
pwd & os.getcwd()\\
rm 'fichier.txt' & os.remove('fichier.txt')
\end{tabular}

Une commande permet de manière plus générale de lancer une commande système :
\begin{verbatim}
os.system('cmd argument')
\end{verbatim}

Par exemple, on peut très bien faire les commandes précédentes via la commande system
\begin{verbatim}
# méthode 1
os.system('cd \'dossier\'')
# méthode 2
os.system("cd 'dossier'")

os.system("mkdir 'dossier'")
os.system("ls")
os.system("pwd")
os.system("rm 'fichier.txt'")
\end{verbatim}

Dans ce même module, il existe une commande très pratique pour tester l'existence d'un fichier ou dossier (pratique pour tester avant suppression ou changement de répertoire, ça évite les bugs du programme)
\begin{verbatim}
nom_fichier = "simulation.log"
if os.path.exists(nom_fichier):
  os.remove(nom_fichier)
\end{verbatim}


Si, par contre, on désire stocker le résultat d'une commande, on ne peut utiliser \texttt{system}. On doit utiliser un autre module, le module \gras[python!commands]{commands} et utiliser la commande suivante
\begin{verbatim}
liste = commands.getoutput("ls")
# facultatif mais utile
liste = liste.split("\n")
\end{verbatim}

\begin{attention}
Préférer les méthodes décrites dans \refsec{sec:subprocess} plutôt que les méthodes du module \gras[module!os]{os}. Je sais plus pourquoi, mais parait que c'est mieux.
\end{attention}

\section{Erreurs}
\subsection{Unindent}
\begin{verbatim}
IndentationError: unexpected indent
\end{verbatim}

C'est normalement dû au fait qu'il y a dans le code source des indentations avec tabulation et espaces. Un simple rechercher/remplacer permet de corriger l'erreur normalement.


\section{Astuces}
\subsection{Copier une liste (et non faire un lien virtuel)}
Par défaut, en python, si vous assignez une variable contenant une liste à une autre variable, la 2e variable sera un lien virtuel vers la première. La conséquence la plus importante est que si vous modifiez la 2e variable, vous modifiez également la première.

\begin{exemple}
\begin{verbatim}
>>> t1 = range(5)
>>> t2 = t1
>>> print t1, t2
[0, 1, 2, 3, 4] [0, 1, 2, 3, 4]
>>> del(t2[2])
>>> print t1, t2
[0, 1, 3, 4] [0, 1, 3, 4]
\end{verbatim}
\end{exemple}

Afin d'éviter ce genre de problèmes, on peut faire les choses suivantes :
\begin{verbatim}
t2 = list(t1)
\end{verbatim}
ou
\begin{verbatim}
t2 = t1[:]
\end{verbatim}


\subsection{Tester si une variable existe}
\begin{verbatim}
try:
  print toto
except NameError:
  print "toto n'existe pas"
\end{verbatim}

ou alors

utiliser la méthode \texttt{has\_key()} des dictionnaires internes répertoriant les variables. Si on veut tester l'existence de la variable $x$  qui est une variable locale ou globale, il faut utiliser respectivement
\begin{verbatim}
vars().has_key('x')
globals().has_key('x')
\end{verbatim}

ou encore
\begin{verbatim}
if ('x' in locals()):
  print("'x' est défini")
\end{verbatim}


\subsection{Tester le type d'une variable}
\begin{verbatim}
>>> liste=['test', 'test']
>>> if isinstance(liste, type([])):
...  print "c'est une liste"
"c'est une liste"
\end{verbatim}

On peut aussi faire
\begin{verbatim}
>>> liste=['test', 'test']
>>> if isinstance(liste, list):
...  print "c'est une liste"
"c'est une liste"
\end{verbatim}

On peut aussi tester plusieurs types à la fois
\begin{verbatim}
>>> liste=['test', 'test']
>>> if isinstance(liste, (list,int)):
...  print "c'est une liste ou un entier"
"c'est une liste"
\end{verbatim}

Sinon, plus simple :
\begin{verbatim}
>>> liste=['test', 'test']
>>> if (type(liste)==list):
...  print "c'est une liste"
"c'est une liste"
\end{verbatim}

Pour connaître le type à rentrer pour le test, il suffit de faire
\begin{verbatim}
>>> liste=['test', 'test']
>>> type(liste)
<type 'list'>
\end{verbatim}
Le type à rentrer est simplement la valeur entre guillemets, donc ici \texttt{list}

\subsection{Arrondir les floats}\index{arrondis}
Il est possible d'arrondir les floats à l'aide de
\begin{verbatim}
>>> test = 1.12456124
>>> round(test,3)
1.12499999
\end{verbatim}

On pourrait croire que ceci ne marche pas. En fait, c'est dû au fait que le processeur arrondi à la valeur la plus proche qu'il connait (penser au fait qu'un ordinateur ne connait pas les réels par défaut).

Si on ne veut que quelques chiffres significatifs, c'est généralement pour un affichage. On n'a alors aucun problème, car lors de la conversion en string du flottant arrondi, il restera les bons chiffres significatifs (à condition qu'on ait fait un round avant, ça va de soi)
\begin{verbatim}
>>> test = 1.12456124
>>> test2 = round(test,3)
>>> str(test2)
'1.125'
\end{verbatim}

\subsection{Lister un type de fichier}
En console, il est possible de lister des types de fichier en utilisant les expressions régulières, comme par exemple
\begin{verbatim}
ls *.txt
ls test*
\end{verbatim}

Avec python, si on souhaite faire ça dans un processus, il faudra utiliser
\begin{verbatim}
process = subprocess.Popen("ls *.txt", shell=True)
\end{verbatim}

En effet, \verb|process = subprocess.Popen(["ls", "*.txt"])| renverra une erreur. Ne me demandez pas pourquoi, j'en sais rien.

\begin{remarque}
Pour récupérer la sortie, il faut bien évidemment faire comme expliqué dans la section \refsec{sec:subprocess}.
\end{remarque}

\subsection{Personnaliser Python}
Cette astuce doit surement fonctionner avec d'autres language, je  n'ai utilisé que python, donc à vous de voir comment généraliser.

Je souhaitais pouvoir exécuter certains scripts python depuis  n'importe quel répertoire sans avoir à entrer le chemin complet. je  souhaitais aussi pouvoir importer les modules que j'ai créé sans  devoir modifier le \texttt{sys.path} à chaque fois et dans chaque  script.

Afin de pouvoir exécuter les scripts depuis n'importe quel dossier,  il faut déjà regrouper tous ces scripts dans un dossier particulier.  Par exemple, j'ai mis dans mon \texttt{/home} un dossier \texttt {python/traitement\_simu} où je stocke les scripts que je veux  exécuter pour chaque simulation, et un dossier \texttt{python/modules} où je stocke tous mes modules.

Les modifications sont à effectuer dans \texttt{.bash\_profile} (voir  \refsec{sec:bashprofile}).

Il faut rajouter le dossier \texttt{python/traitement\_simu} dans la  variable PATH et il faut créer une variable PYTHONPATH

\begin{attention}
Afin que ceci fonctionne, il faut \emph{exporter} ces variables.
\end{attention}

En supposant que votre fichier \texttt{.bash\_profile} est vide (ou  n'existe pas.\footnote{Ce fichier est à placer dans votre \texttt{/home}}), voici ce qu'il faut rajouter :
\begin{verbatim}
PATH=$PATH:$HOME/python/traitement_simu
PYTHONPATH=$HOME/python/modules

export PATH PYTHONPATH
\end{verbatim}

\subsection{Optimisations}
(J'ai eu la flemme de traduire, mais l'idée y est)

If you feel the need for speed, go for built-in functions - you can't beat a loop written in C. Check the library manual for a built-in function that does what you want. If there isn't one, here are some guidelines for loop optimization:

\begin{itemize}
\item Rule number one: only optimize when there is a proven speed bottleneck. Only optimize the innermost loop. (This rule is independent of Python, but it doesn't hurt repeating it, since it can save a lot of work. :-)
\item Small is beautiful. Given Python's hefty charges for bytecode instructions and variable look-up, it rarely pays off to add extra tests to save a little bit of work.
\item Use intrinsic operations. An implied loop in map() is faster than an explicit for loop; a while loop with an explicit loop counter is even slower.
\item Avoid calling functions written in Python in your inner loop. This includes lambdas. In-lining the inner loop can save a lot of time.
\item Local variables are faster than globals; if you use a global constant in a loop, copy it to a local variable before the loop. And in Python, function names (global or built-in) are also global constants!
\item Try to use map(), filter() or reduce() to replace an explicit for loop, but only if you can use a built-in function: map with a built-in function beats for loop, but a for loop with in-line code beats map with a lambda function!
\item Check your algorithms for quadratic behavior. But notice that a more complex algorithm only pays off for large N - for small N, the complexity doesn't pay off. In our case, 256 turned out to be small enough that the simpler version was still a tad faster. Your mileage may vary - this is worth investigating.
\item And last but not least: collect data. Python's excellent profile module can quickly show the bottleneck in your code. if you're considering different versions of an algorithm, test it in a tight loop using the time.clock() function. 
\end{itemize}


\printindex
\end{document}