\documentclass[a4paper,twoside]{article}
\usepackage{autiwa}
\title{}
\author{Autiwa}
\makeindex
\usepackage{color}
\definecolor{gray}{gray}{0.5}
\definecolor{green}{rgb}{0,0.5,0}


\begin{document}
\tableofcontents

\clearpage
Soit on lance l'interpréteur via \verb|python|, soit on exécute un script python, qui doit commencer par les lignes suivantes
\begin{lstlisting}[language=python]
#!/usr/bin/env python
# -*- coding: utf-8 -*-
\end{lstlisting}

La première ligne pour définir que c'est un script python et la deuxième pour spécifier l'encodage du script (pour moi, utf-8).

\section{Pour débuter}
En python, la mise en forme du code est primordiale puisque c'est elle qui détermine comment il est exécuté. Il est conseillé d'utiliser une indentation de 4 espaces (de n'utiliser que des espaces ou que des tabulations, mais une préférences pour les espaces, ne me demandez pas pourquoi\dots)

\subsection{Boucles}\index{boucles}
Pour effectuer une boucle, on fera donc
\begin{lstlisting}[language=python]
for i in range(5):
  print i
print "ici, on n'est plus dans la boucle"
\end{lstlisting}

\begin{lstlisting}[language=python]
list = ['a', 'b', 'c', 'd']
for ele in list:
  print ele
\end{lstlisting}

\begin{lstlisting}[language=python]
a = 0
while (a<1):
  print a
  a += 1
\end{lstlisting}

\begin{lstlisting}[language=python]
a = 0
if (a==0):
  print "a est nul"
elif a==1:
  print "a vaut 1"
else:
  print "a ne vaut ni 0 ni 1"
# fin de la boucle
\end{lstlisting}

\begin{table}[htb]
\begin{tabular}{>{\bfseries}r<{}@{ : }p{11cm}}
Opérateur &	effet\\
a == b & teste si a et b sont égaux\\
a > b & teste si a est strictement supérieur à b\\
a < b & teste si a est strictement inférieur à b\\
a >= b & teste si a est supérieur ou égal à b\\
a <= b & teste si a est inférieur ou égal à b\\
a != b & teste si a et b sont différent
\end{tabular}
\caption{Quelques opérateurs de comparaison en python. Ils renvoient des expressions booléennes. On peut aussi combiner plusieurs tests à l'aide de \texttt{and} et \texttt{or}.}
\end{table}


\begin{remarque}
À noter les fonction \texttt{continue} et \texttt{break} à utiliser dans des boucles. \texttt{continue} permet de sauter la boucle actuelle pour passer à l'itération suivante. \texttt{break}, quant à lui, permet d'arrêter la boucle avant sa fin.
\end{remarque}



\subsection{Types de variable}
Pour déclarer une variable, il suffit de lui attribuer une valeur :
\begin{lstlisting}[language=python]
>>> a = 2
>>> b = 3.4
>>> c = 'Hello World!'
>>> d = [1, 2]
\end{lstlisting}


Par défaut on n'a pas forcément besoin de connaître les noms des types, mais il est toujours intéressant de les connaître, que ce soit pour numpy ou pour tester les types des variables dans des cas particuliers. Les différents types que je connais sont répertoriés dans \reftab{tab:types}.

\begin{table}[htb]
\centering
\begin{tabular}{|>{\tt}c<{}|c|}
\hline
type & description\\\hline
int & un entier\\\hline
float & un réel\\\hline
bool & un booléen (\textbf{True} ou \textbf{False})\\\hline
str & une chaîne de caractères\\\hline
tuple & un tuple, c'est à dire \verb|(1, 2)| par exemple\\\hline
list & une liste : \verb|[1, 2]|\\\hline
dict & un dictionnaire : \verb|{'un':1, 'deux':2}|\\\hline
\end{tabular}

\caption{Liste des types par défaut de python. Ce sont les types les plus utilisés, il y en a sans doute d'autres. Afin de connaître le type d'une variable particulière, il suffit de faire \texttt{type(variable)}.}\label{tab:types}
\end{table}

Ce sont en fait des classes définies par défaut, et les classes personnalisées auront leur propre type. 

\bigskip

On peut bien entendu tester le type d'une variable et décider de la marche à suivre en fonction. Des exemples sont donnés dans \refsec{sec:test-type-variable}.

\subsection{Formater des chaînes de caractère}
On peut bien entendu faire des choses de ce genre : 
\begin{lstlisting}[language=python]
print('Il y a '+str(count)+' choses.')
\end{lstlisting}
mais c'est rapidement ennuyeux à écrire, et on ne contrôle pas l'affichage des informations. Pour donner un exemple de l'opérateur de formattage des chaînes de caractères, voici comment écrire la ligne plus haut, avec l'opérateur \og\%\fg :
\begin{lstlisting}[language=python]
print('Il y a %d choses.' % (count))
\end{lstlisting}
où \texttt{\%d} indique que la variable sera un entier.

\begin{remarque}
Après le caractère \og\%\fg, le tuple contient la liste des variables à afficher, dans l'ordre d'apparition des marqueurs tels \texttt{\%d}.
\end{remarque}

Un format de conversion contient au moins 2 caractères et a les éléments suivants dans cet ordre :
\begin{itemize}
\item Le caractère \og\%\fg qui marque le début du format de conversion
\item (optionnel) \textbf{une clé} \texttt{keyValue}, spécifiée entre parenthèse \texttt{(keyValue)} , pour le cas où la liste des variables est donnée dans un dictionnaire et non dans un tuple
\item (optionnel) \textbf{les options de conversions} (listées plus bas), qui affectent le résultat dans certains types de conversion.
\item (optionnel) \textbf{la longueur minimale du champ considéré}. Si cette longueur est donnée par une astérisque \og *\fg, la longueur actuelle est lue dans le tuple de valeurs. Ainsi, pour une valeur donnée, avec cette option, trois valeurs seront lues dans le tuple, la première sera la longueur minimale du champ, la deuxième sera la précision de la conversion, et la troisième sera la valeur à convertir.
\item (optionnel) \textbf{la précision}, donnée par un point suivi de la valeur de la précision \texttt{.d}. Si spécifiée par une astérisque \og * \fg, la largueur réelle sera lue dans le tuple, et l'élément encore après sera la valeur à convertir.
\item (optionnel) permet de modifier la longueur
\item type de conversion
\end{itemize}

Voici un exemple qui montre comment se servir de certaines options, dont la clé en particulier : 
\begin{lstlisting}[language=python]
>>> print '%(language)s has %(#)03d quote types.' % \
          {'language': "Python", "#": 2}
Python has 002 quote types.
\end{lstlisting}

De manière équivalente, on peut écrire :
\begin{lstlisting}[language=python]
>>> print '%s has %03d quote types.' % \
          ("Python",  2)
Python has 002 quote types.
\end{lstlisting}

Les caractères suivants sont les options de conversion disponibles :
\begin{itemize}
\item[\emph{\#}]: La valeur a convertir utilisera la forme alternative (définie plus bas)
\item[\emph{0}]: La conversion sera complétée par des \og0\fg pour les valeurs numériques.
\item[\emph{-}]: la valeur convertie est ajustée à gauche (écrase les \og0\fg si les deux sont donnés)
\item[\emph{ }]: (un espace) Un blanc devrait être laissé avant un nombre positif (ou une chaîne vide) produite par une conversion signée.
\item[\emph{+}]: Un caractère représentant le signe (\og+\fg ou \og-\fg) précèdera la conversion (écrase l'option \og espace\fg)/
\end{itemize}

Dans ce tableau, les lettres suivantes (en italique) ont une signification :
\begin{itemize}
\item[\emph{w}]: Le nombre de position à utiliser (l'espace à réserver pour l'affichage). Si le nombre réellement nécessaire est supérieur, ce nombre n'est pas pris en compte. (en clair, si vous dites de réserver 2 caractères, mais qu'il en faut 6 pour afficher le nombre, il en utilisera 6, mais si vous dites d'en réserver 6 et qu'il vous en faut 2, alors il laissera des blancs, par défaut à gauche)
\item[\emph{m}]: La précision (qui peut parfois devenir les chiffres significatifs dans la version alternative). C'est la précision au delà de la virgule dans le cas de nombre réels.
\end{itemize}

Même si on peut afficher un nombre avec autant de positions qu'on veut, c'est juste une question d'affichage, ce nombre de positions n'a rien à voir avec la précision (i.e le nombre de chiffres significatifs). 
\begin{table}
\begin{center}
\begin{tabular}{|p{2cm}|l||l|l|l|l|}
\hline
\multicolumn{2}{|c||}{But} & \multicolumn{2}{c|}{Descripteur} & Rendu & Alt\\\hline
\multirow{5}{2cm}{Afficher des entiers} & décimal signé & \%d & \%\emph{w}.\emph{m}d & -20 &\\\cline{2-6}
 & décimal signé & \%i & \%\emph{w}.\emph{m}i & -20 &\\\cline{2-6}
 & octal signé & \%o & \%\emph{w}.\emph{m}o & -24 & -024\\\cline{2-6}
 & hexadécimal signé & \%x & \%\emph{w}.\emph{m}x & -14 & -0x14\\\cline{2-6}
 & hexadécimal signé & \%X & \%\emph{w}.\emph{m}X & -14 & -0X14\\\hline
\multirow{6}{2cm}{Afficher des réels} & Format exponentiel & \%e & \%\emph{w}.\emph{m}e & -2.000000e+01 & \footnotemark[103]\\\cline{2-6}
 & Format exponentiel & \%E & \%\emph{w}.\emph{m}E & -2.000000E+01 & \footnotemark[103]\\\cline{2-6}
 & Format décimal & \%f & \%\emph{w}.\emph{m}f & 20.000000 & \footnotemark[103]\\\cline{2-6}
 & Format décimal & \%F & \%\emph{w}.\emph{m}F & 20.000000 & \footnotemark[103]\\\cline{2-6}
 & Format hybride \footnotemark[101] & \%g & \%\emph{w}.\emph{m}g & 20 & 20\footnotemark[104]\\\cline{2-6}
 & Format hybride \footnotemark[101] & \%G & \%\emph{w}.\emph{m}G & 20 & 20\footnotemark[104]\\\hline
\multirow{3}{2cm}{Afficher des caractères} & Un seul caractère \footnotemark[102] & \%c & \%\emph{w}.\emph{m}c & ' ' & ' '\\\cline{2-6}
 & Une chaîne de caractère & \%s & \%\emph{w}.\emph{m}s & '20' & '20'\\\cline{2-6}
 & Un booléen & \%s & \%s & 'True' & 'True'\\\hline
\end{tabular}
\end{center}
\caption{Liste des formats d'affichage de variables en python, utilisant le descripteur de format \%}\label{tab:formats}
\end{table}
\footnotetext[101]{exponentiel si l'exposant est inférieure à -4}
\footnotetext[102]{Accepte comme valeur un caractère, ou un entier désignant un caractère (en ASCII)}
\footnotetext[103]{Affiche toujours un point, même s'il n'y a aucune décimale à afficher après.}
\footnotetext[104]{Ne supprime pas le point décimal. La précision représente le nombre de chiffres significatifs}

\bigskip

Voici des exemples concrêts pour l'affichage d'un flottant normal : 
\begin{verbatim}
>>> t=2.3500000
>>> print("%d"%t)
2
>>> print("%f"%t)
2.350000
>>> print("%.2f"%t)
2.35
>>> print("%.4f"%t)
2.3500
>>> print("%7.2f"%t)
   2.35
>>> print("%5.2f"%t)
 2.35
\end{verbatim}

D'autres exemples pour l'affichage de chiffres significatifs (à l'aide de la forme hybride): 
\begin{verbatim}
>>> t=0.01
>>> print("%.1g"%t)
0.01
>>> t=0.1
>>> print("%.1g"%t)
0.1
>>> t=1.
>>> print("%.1g"%t)
1.
>>> t=10.
>>> print("%.1g"%t)
1e+01
\end{verbatim}

En voici d'autres pour un réels déclaré sous la forme d'une exponentielle :
\begin{verbatim}
>>> t=3.875786e17
>>> print("%e" % t)
3.875786e+17
>>> print("%f" % t)
387578600000000000.000000
>>> print("%d" % t)
387578600000000000
>>> print("%.2e" % t)
3.88e+17
>>> print("%10.2e" % t)
  3.88e+17
>>> print("'%-10.2e'" % t)
'3.88e+17  '
\end{verbatim}

Et pour un entier :
\begin{verbatim}
>>> print("%0*i_total_torque.png" % (len, value))
012_total_torque.png
\end{verbatim}
qui ici met en forme \texttt{value}, mais complète avec des 0 à gauche pour atteindre une longueur totale de \texttt{len}.

\bigskip

Il existe aussi une astuce extrêmement pratique, c'est d'écrire la chaîne sans passer de variable, pour les passer plus tard. Comme c'est difficile à expliquer, voici un exemple : 
\begin{verbatim}
error_message = "The variable %s is not well defined" 

print(error_message % variable_name)
\end{verbatim}
Ceci permet de gérer des messages d'erreurs de manière propre sans avoir à marquer la même phrase partout et sans connaître \textit{a priori} les valeurs que l'on souhaite afficher. 

Ceci marche aussi avec des chaînes de caractères très longues comme des fichiers de paramètres que l'on définirait ainsi : 
\begin{verbatim}
PARAMETER_FILE = """
!# the smoothing length for the planet's potential
b/h = %.2f

!# the adiabatic index for the gas equation of state
adiabatic_index = %.2f

!# the mean molecular weight in mass of a proton
mean_molecular_weight = %.2f"""
\end{verbatim}
et qu'on créerait de la manière suivante : 
\begin{verbatim}
object_file = open("parameter_file.in", 'w')
object_file.write(PARAMETER_FILE % (b_h, adiabatic_index, mmw))
object_file.close()
\end{verbatim}

\subsection{Lire un fichier de données}
Ici je ne parle pas de lire un fichier de paramètres, mais bien des données, formatées en colonnes, avec un entête et des formats variés. 

Je ne vais pas forcément détailler tout ce qu'on peut faire, mais simplement montrer la commande de base, du module numpy, ainsi que les options les plus utiles : 
\begin{lstlisting}[language=python]
import numpy as np

(t, a, e, I, m) = np.loadtxt('data.dat', skiprows=4, usecols = (0,1,2,3,7), dtype=float, unpack=True)
\end{lstlisting}
Dans un fichier \texttt{data.dat} qui contient au moins 8 colonnes, on ne conserve que les 4 premières et la 8e colonne, qu'on définit comme étant des flottants. Les 4 premières lignes ne sont pas prises en compte, et sont l'entête du fichier.

\begin{attention}
La commande \textbf{loadtxt} ne permet pas d'utiliser l'option \texttt{unpack=True} dans le cas où les données n'ont pas le même type. En effet, dans ce cas là, c'est plus compliqué de définir l'option \textbf{dtype} (je ne le détaille pas ici), mais ça empêche l'utilisation de l'option \textbf{unpack}. Il faut se tourner vers la fonction \textbf{genfromtxt} dans ce cas là.
\end{attention}


On n'est pas obligé de définir les types des colonnes ou le délimiteurs. Par défaut, j'utilise la ligne suivante : 
\begin{lstlisting}[language=python]
import numpy as np

(a, b) = np.loadtxt('data.dat', skiprows=4, usecols = (0,1), dtype=float, unpack=True)
\end{lstlisting}

\begin{remarque}
Spécifier les options, comme le type des données, permet d'accélérer la lecture du fichier. Pour une fichier de \nombre{200000} lignes, j'ai ainsi gagné environ 5 secondes sur le temps de lecture.
\end{remarque}

\bigskip

Il existe une commande sensiblement équivalente, \textbf{np.genfromtxt}, qui permet de mieux gérer les absences de données s'il y en a. En contre partie, cette fonction est plus lente que \textbf{loadtxt}, donc je n'en parle pas ici. Son fonctionnement est très similaire de toute manière.

\subsection{Lire des données depuis un fichier texte}
Outre la méthode classique en ouvrant le fichier, il est possible de directement récupérer les données avec une fonction du module \gras{numpy} : 
\begin{lstlisting}[language=python]
import numpy as np
# Read in data from an ASCII data table
data = np.genfromtxt('datafile.txt')

#'data' is a matrix containing the columns and rows from the file
mass   = data[:,0]  # Python indices are (row,col) as in linalg
radius = data[:,1]  # Creates arrays for first two columns
\end{lstlisting}


\subsection{Débug}
Pour celà, il existe le module \gras[module!pdb]{pdb} qui sert à ça.

On l'importe de la façon suivante
\begin{lstlisting}[language=python]
import pdb
\end{lstlisting}

La commande utile, si on ne doit en retenir qu'une est :
\begin{lstlisting}[language=python]
pdb.set_trace()
\end{lstlisting}

Cette commande stoppe le programme et donne la main à l'interpréteur, nous permettant de regarder l'état des variables. Il permet aussi de continuer le programme ligne à ligne, mais je sais pas encore comment.

Ensuite, on peut taper des commandes python, notamment pour évaluer les variables. Mais il existe aussi des commandes propres au débuguage donc voici une liste des plus utiles :
\begin{itemize}
\item[s] continue l'exécution et s'arrête dès que possible (en gros, si tout va bien, s'arrête à la ligne suivante)
\item[r] continue l'exécution jusqu'à la fin de la fonction en cours (s'arrête juste avant le return s'il y en a un il me semble)
\end{itemize}
Sinon, pour quitter, \touche{Ctrl}+\touche{C}, ou \texttt{exit()}

\section{Fonctions}
On peut bien évidemment créer des fonctions en python. Une fonction très simple serait
\begin{lstlisting}[language=python]
def affiche(variable):
  print variable
\end{lstlisting}
qui se contenterait d'afficher le contenu de la variable passée en argument.

Une fonction peut retourner des valeurs via \verb|return variable|. Cette fonction peut renvoyer plusieurs valeurs, on aura donc :
\begin{lstlisting}[language=python]
def produit_somme(a,b):
  somme = a + b
  produit = a * b
  return somme, produit_somme

(sum_ab, prod_ab) = produit_somme(2,3)
\end{lstlisting}

On peut aussi avoir des paramètres optionnels, à qui on donne une valeur par défaut :
\begin{lstlisting}[language=python]
def test(a, b=3)
  print a*b
\end{lstlisting}

On peut aussi gérer un nombre inconnu de variable :
\begin{lstlisting}[language=python]
def test(*args):
  for arg in args:
    print arg
test('coucou', 2, 1, range(2))
test('coucou', 2)
\end{lstlisting}

Ceci peut s'ajouter à d'autres variables, elles obligatoires :
\begin{lstlisting}[language=python]
def test(nom, *variables):
  print nom
  for var in variables:
    print var
test('coucou', 2, 1, range(2))
test('coucou', 2)
\end{lstlisting}

\subsection{Documenter une fonction}
\source{tuto de suzy}

Une dernière chose très importante lorsque vous définissez une fonction, c'est sa documentation ! Vous allez commencer à documenter votre code pour le rendre plus compréhensible et exploitable par d'autres personnes que vous. Pour cela, c'est très simple, il suffit de placer immédiatement sous la ligne de définition de votre fonction, une chaîne de caractères entre triple 'quote' (""" ou ''') qui sera considérée un commentaire.

\begin{lstlisting}[language=python]
def fonction(arg1, arg2) :
    """
    Je documente ma fonction. 
    J'explique rapidement a quoi sert cette fonction.
    arg1 : J'ecris a quoi correspond cet argument.
    arg2 : J'ecris a quoi correspond cet argument.
    return : J'indique ce que retourne la fonction
    """
    pass
\end{lstlisting}

Voici un exemple d'une manière simple de documenter clairement vos fonctions. Il faut au minimum expliquer ce que fait la fonction. Une documentation complète détaille aussi le sens de chacun des arguments et ce que retourne la fonction. Avec une bonne documentation, personne ne doit avoir besoin de lire le code pour comprendre à quoi sert la fonction et ce qu'elle fait. Cela permet de la conserver en tant que boîte noire qui ne regarde que celui qui l'a implémentée.

\begin{remarque}
Le mot clé \gras{pass} vous permet de sortir d'une structure. Il peut être utile par exemple lorsque vous développez un projet. Une bonne technique de développement étant de définir les fonctions puis l'algorithme principal et enfin d'implémenter les fonctions. Ce mot clé vous permet donc d'avoir toutes vos fonctions définies sans avoir à les implémenter à l'avance.
\end{remarque}

\subsection{Passer plusieurs arguments d'une fonction à l'aide d'une séquence}\label{sec:args_liste}
Il est tout à fait possible de passer pour ce type d'argument une séquence, pour cela, il suffit de la faire précéder d'une étoile pour la convertir.

\begin{lstlisting}[language=python]
def fonction(*arguments) :
    """Test de fonction avec un nombre indefini d'arguments.
    arguments : Une sequence a ecrire en console."""
    for element in arguments :
        print(element)

fonction(*'abcdef')
\end{lstlisting}

Si vous n'utilisez pas l'opérateur '*', votre séquence sera alors considérée comme n'étant qu'un seul argument ! Cela est dû au typage dynamique. En effet, n'importe quel argument de votre fonction peut prendre n'importe quel type, il faut donc préciser ici que chaque élément de la séquence est un argument à part entière.

\subsection{Nombre indéfini d'arguments}
\source{tuto de suzy}

Il existe des fonctions qui acceptent un nombre indéterminé d'arguments, c'est le cas de la fonction print par exemple. Comment cela fonctionne-t-il ? Et bien, c'est assez simple. Pour cela, il est possible de le faire de deux manières : avec des arguments anonymes ou avec arguments associés à des clés. Nous allons donc voir les deux manières de créer des fonctions avec un nombre indéterminé de paramètres.

\subsubsection{Arguments anonymes}

La syntaxe est particulièrement simple. En fait, vous allez préciser une séquence (liste, tuple ou chaîne de caractères) comme argument. Le fait que cet argument doivent être une séquence se précise par l'utilisation de l'opérateur '*' juste avant le nom de l'argument :

\begin{lstlisting}[language=python]
def fonction(*arguments) :
    """Test de fonction avec un nombre indefini d'arguments.
    arguments : Une sequence a ecrire en console."""
    for element in arguments :
        print(element)

fonction(43, 38, "Peuh !", True)
\end{lstlisting}

De cette façon, il est donc possible d'appeler ma fonction avec un nombre indéfini d'arguments mais attention, cela est possible à une seule condition : la séquence d'arguments doit impérativement se situer en dernier argument de la fonction ! Les arguments s'écrivent donc dans l'ordre suivant dans la déclaration d'une fonction : les arguments obligatoires, les arguments avec valeur par défaut (facultatifs) et enfin des arguments supplémentaires si nécessaires.

En utilisant l'astuce \refsec{sec:args_liste} ça donne :
\begin{lstlisting}[language=python]
def fonction(*arguments) :
    """Test de fonction avec un nombre indefini d'arguments.
    arguments : Une sequence a ecrire en console."""
    for element in arguments :
        print(element)

fonction(*'abcdef')
\end{lstlisting}

\subsubsection{Arguments avec clé}

Si vous voulez associer une clé à chacun des arguments que vous donnez en supplément à une fonction, il va falloir utiliser un dictionnaire. Et ce coup-ci, c'est l'opérateur '**' qui sera utilisé.

\begin{lstlisting}[language=python]
def fonction(**arguments) :
    """Test de fonction avec un nombre indefini d'arguments.
    arguments : Un dictionnaire a ecrire en console."""
    for cle in arguments :
        print(cle,arguments[cle])

fonction(arg1 = 'Peuh !', arg2 = 38)
\end{lstlisting}

Vous verrez en exécutant ce code que l'on peut donc facilement créer des couples (clé,valeur) à passer en paramètre. La contrainte est la même que précédemment et le dictionnaire d'arguments doit être impérativement placé en dernier dans la liste d'arguments lors de la déclaration de la fonction. Encore une fois, pour convertir un dictionnaire non pas un seul argument mais en une suite d'arguments, il faut utiliser l'opérateur '**' devant le dictionnaire passé en argument.

\begin{lstlisting}[language=python]
def fonction(**arguments) :
    """Test de fonction avec un nombre indefini d'arguments.
    arguments : Un dictionnaire a ecrire en console."""
    for cle in arguments :
        print(cle,arguments[cle])

fonction(**dict(arg1 = 'Peuh !', arg2 = 38))
\end{lstlisting}

\subsection{Importer des fonctions}\label{sec:importer_fonctions}\index{importer des modules}
On peut importer des fonctions très facilement. Il convient pourtant de prendre de bonnes habitudes dès le départ. Par exemple, pour importer la fonction \texttt{sin()}, on peut choisir une des lignes suivantes :
\begin{lstlisting}[language=python]
import math
from math import *
from math import sin
import math as m
\end{lstlisting}

Ceci est donné uniquement à titre d'exemple. La première ligne importe toute la librairie math, et pour appeler la fonction sinus, il faudra faire \texttt{math.sin(x)}

Dans le cas de la deuxième ligne, on pourra faire  \texttt{sin(x)}

La 3\ieme ligne est identique à la 2\ieme à ceci près qu'elle n'importe que la fonction sinus, et pas les autres fonctions de la librairie math. Ça permet de gagner un peu de place en n'important que ce dont on a besoin.

La 4\ieme et dernière ligne importe toute la librairie math et définit un alias à celle ci. Ainsi, pour appeler la fonction sinus, on fera \texttt{m.sin(x)}.

\bigskip

Maintenant, voici ce qu'il faut éviter de faire : Il ne faut pas utiliser les lignes 2 ou 3 qui nous font perdre l'information d'où provient la fonction qu'on utilise.

Personnellement, je continue à le faire pour la librairie math, mais c'est la seule exception. Par exemple pour les plots, j'utilise \gras{pylab} via
\begin{lstlisting}[language=python]
import pylab as pl
\end{lstlisting}
Ce qui fait que quand j'utilise une fonction via \texttt{pl.nomdefonction()} je sais qu'elle provient de la librairie pylab.

L'autre avantage de cette méthode est qu'elle permet d'éviter les conflits entre deux fonctions qui auraient le même nom, et provenant de librairies différentes\footnote{Par exemple la librairie pylab définit d'autres fonction trigonométriques (\texttt{sin()}, \dots)}.

Enfin le dernier avantage, et non le moindre, est qu'en important via \texttt{import \emph{module}} ou \texttt{import \emph{module} as \emph{alias}}, ne seront chargé en mémoire que les fonctions effectivement utilisées.

\begin{attention}
Avec \texttt{from \emph{module} import *}, on importe absolument tout, y compris les variables qui pourraient être définies. C'est donc à éviter, sauf cas particulier.
\end{attention}





\section{Manipuler des fichiers}\index{fichier!lire}\index{fichier!écrire}
Pour manipuler un fichier, il faut dans un premier temps l'ouvrir (et spécifier si on veut pouvoir écrire, lire, ou écrire sans effacer le fichier au moment de l'ouverture), puis effectuer diverses opérations dans un second temps et enfin le fermer.

\begin{lstlisting}[language=python]
fichier = open("fichier.txt",'w')
fichier.write("ligne 1\nligne 2")
fichier.close()
\end{lstlisting}
\verb|'w'| signifie que l'on souhaite écrire dans le fichier. Il signifie aussi que le fichier sera effacé lors de l'ouverture (au cas où le fichier existe). Si on ne souhaite pas effacer le fichier, il faut utiliser \verb|'a'| qui va permettre d'écrire à la suite du fichier.

Par exemple, voici la fonction que j'utilise pour écrire un fichier log de mon script.

\begin{lstlisting}[language=python]
def writelog(texte_log)
  log = open(nom_fichier_log,'a')
  log.write("["+str(time.strftime('%d/%m/%Y'\
 %H:%M:%S'))+"] "+texte_log+"\n")
  log.close()
\end{lstlisting}
(cette fonction ne retourne rien vu qu'il n'y en a pas besoin. Au début, je mettais \verb|return 0| mais pour l'instant je l'ai enlevé).

\bigskip

Pour lire un fichier, on procède de la manière suivante
\begin{lstlisting}[language=python]
fichier = open("fichier.txt",'r')
t = fichier.readlines()
fichier.close()
\end{lstlisting}

Le fichier $t$ est une liste comprenant un élément pour chaque ligne du fichier lu. \texttt{fichier.readline()} ne lit qu'une seule ligne à la fois. \texttt{fichier.read(nb)} permet de lire \texttt{nb} caractères à partir de là où s'était arrêté la lecture.

\begin{remarque}
À noter que chaque ligne se termine par \verb|\n|.
\end{remarque}

\section{Modules}
Pour les commandes basiques d'importations, se reporter à \refsec{sec:importer_fonctions}.

\subsection{Importer des modules qui ne sont pas dans le répertoire courant.}\index{importer des modules}
En ajoutant
\begin{lstlisting}[language=python]
import sys
sys.path.append(monchemin)
\end{lstlisting}
on peut spécifier un nouveau chemin pour un répertoire contenant des modules. Ainsi, python vérifiera dans ce dossier si le module qu'on souhaite importer s'y trouve (en plus des autres répertoires définis automatiquement et du répertoire courant)

\bigskip

Depuis Python 2.5, il est également possible d'effectuer des importations relatives. Pour cela, il vous faut d'abord créer un fichier \verb|__init__.py| dans le répertoire contenant les modules à importer. Ce fichier peut être vide. Par exemple, considérons un répertoire locale qui contient un répertoire \texttt{A} lui même contenant un fichier \verb|__init__.py| vide et un fichier \texttt{testA.py}. Depuis votre répertoire local, vous pouvez importer \texttt{testA} par l'instruction \texttt{import A.testA}, \texttt{from A import testA} ou \texttt{from A.testA import *}.

\subsection{subprocess}\label{sec:subprocess}\index{subprocess}
Pour lancer une commande dans un processus séparé on fait :
\begin{lstlisting}[language=python]
process = subprocess.Popen("ls")
\end{lstlisting}

Il y a en pratique deux techniques. Où bien on lance la commande et les arguments en séparant :
\begin{lstlisting}[language=python]
process = subprocess.Popen(["ls", "-l"])
\end{lstlisting}
ou bien on lance une chaîne de caractère, et dans ce cas, on spécifie que c'est ce qu'on veut exécuter dans le terminal
\begin{lstlisting}[language=python]
process = subprocess.Popen("ls -l", shell=True)
\end{lstlisting}

\bigskip

Pour récupérer la sortie de la commande, on y accès via
\begin{lstlisting}[language=python]
sortie = process.stdout.readlines()
\end{lstlisting}
à condition d'avoir lancé le script avec l'option \verb|stdout=subprocess.PIPE| ; dans le cas de l'exemple précédent, ça donne donc :
\begin{lstlisting}[language=python]
process = subprocess.Popen("ls -l", shell=True, stdout=subprocess.PIPE)
sortie = process.stdout.readlines()
print sortie
\end{lstlisting}

\begin{remarque}
\verb|sortie| est donc un objet-fichier (la même chose que si on avait fait \texttt{sortie = open("fichier.txt", 'r')}).
\end{remarque}


Sinon, on peut écrire la sortie dans un fichier de la façon suivante :
\begin{lstlisting}[language=python]
sortie = open("sortie.txt", 'w')
process = subprocess.Popen("ls -l", shell=True, stdout=sortie)
sortie.close()
\end{lstlisting}

Pour que le script attende la fin du processus avant de continuer, on fait
\begin{lstlisting}[language=python]
fail = process.wait()
\end{lstlisting}
à quoi on peut rajouter un
\begin{lstlisting}[language=python]
if (fail==0):
  print "OK"
else:
  print "fail"
\end{lstlisting}

\section{Tout savoir sur les listes}\index{liste}
On définit une liste de la façon suivante :
\begin{lstlisting}[language=python]
a = [1.2, 2.3, 4.1, 5.7]
\end{lstlisting}

On peut appeler un élément à l'aide de crochets. On aura
\begin{lstlisting}[language=python]
a[0] = 1.2
a[-1] = a[3] = 5.7
a[-2] = a[2] = 4.1
\end{lstlisting}

On peut rajouter un élément à la liste via
\begin{lstlisting}[language=python]
a.append(6.8)
\end{lstlisting}
On aura alors
\begin{lstlisting}[language=python]
a = [1.2, 2.3, 4.1, 5.7, 6.8]
\end{lstlisting}

pour avoir le nombre d'éléments de la liste, il suffit de faire
\begin{lstlisting}[language=python]
nb = len(a)
\end{lstlisting}

Pour supprimer d'une liste les $n$ premiers éléments et les $m$ derniers, on fera
\begin{lstlisting}[language=python]
for indice in range(n):
  del(liste[0])

for indice in range(m):
  del(liste[-1])
\end{lstlisting}

Pour récupérer l'indice d'une certaine valeur dans une liste :
\begin{lstlisting}[language=python]
>>> a.index(2.3)
1
\end{lstlisting}


\bigskip

Il existe aussi les fonctions \gras{map} et \gras{zip} qui ont le même principe que sous Maple.

La fonction \gras{zip} retourne une liste de tuples
\begin{lstlisting}[language=python]
>>> print zip(['a', 'b', 'c'], [1, 2, 3])
[''a', a), ('b', 2), ('c', 3)]
\end{lstlisting}

\begin{remarque}
Ça marche aussi avec plusieurs séquences. Les chaînes de caractères sont considérées comme des séquences, on peut donc les zipper aussi.

À noter que la sortie de la commande sera de la même longueur que la liste la plus courte passée en arguments.
\end{remarque}

La fonction \gras{map} applique une fonction à chaque élément de la séquence passée en argument.

\begin{lstlisting}[language=python]
>>> print map(abs, [-5, -7, -12])
[5, 7, 12]
\end{lstlisting}
qui est l'équivalent de
\begin{lstlisting}[language=python]
>>> print [abs(i) for i in [-5, -7, -12]]
[5, 7, 12]
\end{lstlisting}
à part le fait que \gras{map} est plus rapide.

Il est possible d'utiliser sa propre fonction. Il est possible d'utiliser une fonction qui nécessite plusieurs arguments, et de passer plusieurs listes à la fonction \gras{map}.
\begin{lstlisting}[language=python]
>>> print map(max, [4, 5, 6], [1, 2, 9])
[4, 5, 9]
\end{lstlisting}

\bigskip

Il est possible de convertir une liste en tuple via la commande \texttt{tuple}
\begin{lstlisting}[language=python]
>>> a = [1, 2, 3]
>>> tuple(a)
(1, 2, 3)
\end{lstlisting}

\subsection{Sélectionner une partie d'une liste}
Il est possible de prendre une partie de liste :
\begin{lstlisting}[language=python]
>>> t = range(5)
>>> t
[0, 1, 2, 3, 4]
>>> t[1:3]
[1, 2]
\end{lstlisting}

\begin{attention}
À partir d'une liste d'indice \texttt{[i:j]}, python retourne les éléments allant de $i$ à $j-1$. Ainsi pour une liste de $n$ éléments, aux indices allant de $0$ à $n-1$, pour avoir la liste complète en spécifiant les indices il faut faire :
\begin{lstlisting}[language=python]
>>> liste[0:n]
[0, ..., n-1]
\end{lstlisting}
\end{attention}


\subsection{List-comprehension}\index{list-comprehension}
Cette technique permet d'agir sur les listes très simplement et très rapidement. Dans bien des cas (pour ne pas dire tous), cette méthode sera plus rapide que l'équivalent avec une boucle :
\begin{lstlisting}[language=python]
list2 = [element * 2 for element in list]
list3 = [element + 3 for element in list if element>3]
\end{lstlisting}

\subsection{Array et Numpy}\index{numpy}\index{array}\index{matrice}
\begin{lstlisting}[language=python]
import numpy as np
\end{lstlisting}

Permet de multiplier terme à terme des matrices de manière très simple. On définit une matrice paragraph
\begin{lstlisting}[language=python]
m = np.array([[1, 2, 3], [4, 5, 6]])
\end{lstlisting}

Après avoir galéré pendant plusieurs heures pour créer et remplir une matrice au fur et à mesure, j'ai trouvé plus pratique de définir une liste comme on le souhaite, avec la souplesse que l'on connait de Python, puis convertir cette liste en array pour faire les calculs.

\bigskip

Dans la suite, on considère une matrice \texttt{m}. On effectue la somme de tous les éléments de la matrice par
\begin{lstlisting}[language=python]
>>> m.sum()
21
\end{lstlisting}

Pour effectuer la somme des éléments colonne par colonne (on somme donc sur l'indice des lignes, c'est à dire le premier indice) :
\begin{lstlisting}[language=python]
>>> m.sum(axis=0)
array([5, 7, 9])
\end{lstlisting}

La même chose ligne par ligne (on somme donc sur les colonnes avec le numéro de ligne fixé) :
\begin{lstlisting}[language=python]
>>> m.sum(axis=1)
array([ 6, 15])
\end{lstlisting}

\begin{remarque}
Apparemment, il existe \texttt{np.append(array, truc-à-rajouter, options)} qui permet de rajouter un truc à un array, et notamment de spécifier si on veut en ligne ou en colonne. Le truc c'est qu'apparemment, il reconstruit la matrice à chaque fois, donc pas sur qu'on gagne en temps d'exécution.
\end{remarque}

\texttt{np.zeros()} et \texttt{np.empty()} permettent de définir des matrices en spécifiant leur taille
\begin{lstlisting}[language=python]
np.zeros((2,3))
\end{lstlisting}

Il est possible (et c'est très pratique) de définir une matrice de la même taille qu'une autre, en spécifiant qu'on ne souhaite que des 0 ou une matrice vide. Pour celà, on utilise
\begin{lstlisting}[language=python]
np.zeros_like(m)
np.empty_like(m)
\end{lstlisting}

\subsubsection{Manipulation des indices}
On peut être amené à trier des listes, ou calculer le minimum ou maximum d'une liste. Mais il peut être encore plus intéressant de récupérer les indices de ces choses là. 

Voici des exemples pour récupérer les indices pour le minimum et maximum : 
\begin{lstlisting}[language=python]
m.argmax()
m.argmin()
\end{lstlisting}
où m est une liste numpy.

Si on veut récupérer les indices correspondant à un tri : 
\begin{lstlisting}[language=python]
m.argsort()
\end{lstlisting}

\bigskip

Si on veut appliquer ça à des listes ou tuples qui ne sont pas des objets numpy, on peut faire : 
\begin{lstlisting}[language=python]
np.argmax(m)
np.argmin(m)
np.argsort(m)
\end{lstlisting}

\subsubsection{Manipulation des array}
On peut sélectionner les valeurs répondant à un ou plusieurs critères avec :
\begin{lstlisting}[language=python]
a[a<2.]
a[(a<10) & (a>2)]
\end{lstlisting}

Pour modifier des sous listes, il faut faire attention à ce qu'on manipule. 

\begin{lstlisting}[language=python]
a[a<2.] = a * 10
\end{lstlisting}
ne va pas multiplier tous les éléments inférieurs à $2.$ par $10$ car les indices du sous-tableau se voient affecter la multiplication par 10 de l'indice correspondant du tableau non modifié. Ainsi le 2\ieme élément du sous-tableau vaudra 10 fois le 2\ieme élément du tableau complet !

Pour faire cette opération il faut faire :
\begin{lstlisting}[language=python]
too_low = a < 2.
a[too_low] = a[too_low] * 10
\end{lstlisting}

\bigskip

Ces tests suppriment automatiquement les valeurs 'nan' qui ne vérifient aucun test. Si on veut juste supprimer les 'nan', on peut faire :
\begin{lstlisting}[language=python]
a[np.isfinite(a)]
\end{lstlisting}

\subsection{Générer des listes entre deux valeurs extrêmes}
La façon la plus simple de faire une liste de valeurs est la fonction \textbf{range} : 
\begin{lstlisting}[language=python]
>>> range(5)
[0, 1, 2, 3, 4]
>>> range(1,5)
[1, 2, 3, 4]
>>> range(1,12,3)
[1, 4, 7, 10]
\end{lstlisting}

Pour définir des listes de valeurs non entières, il existe les fonctions \textbf{linspace} et \textbf{arange} du module \gras{numpy}. La fonction \textbf{linspace} a l'avantage d'inclure la valeur finale par défaut (comportement que l'on peut changer dans les options).

\begin{lstlisting}[language=python]
>>> np.linspace(0.3,0.7, 2)
array([ 0.3,  0.7])
>>> np.linspace(0.3,0.7, 5)
array([ 0.3,  0.4,  0.5,  0.6,  0.7])
\end{lstlisting}

On peut aussi définir les valeurs extrémales dans un tuple : 
\begin{lstlisting}[language=python]
>>> b = (0.3, 0.7)
>>> np.linspace(*b, num=5)
array([ 0.3,  0.4,  0.5,  0.6,  0.7])
\end{lstlisting}

\section{Programmation objet}
\subsection{Les fonctions sont des objets}
Voici une astuce pour choisir une fonction en fonction de la valeur d'un paramètre, ceci de façon rapide et lisible :
\begin{lstlisting}[language=python]
def function1():
    print 'You chose one.'
def  function2():
    print 'You chose two.'
def  function3():
    print 'You chose three.'
#
# switch est notre dictionnaire de functions
switch = {
    'one': function1,
    'two': function2,
    'three': function3,
    }
#
# le choix peut etre 'one', 'two', or 'three'
choice = raw_input('Enter one, two, or three :')
#
# call one of the functions
try:
    result = switch[choice]
except KeyError:
    print 'I didn\'t understand your choice.'
else:
    result()
\end{lstlisting}

\verb|result = switch[choice]| est la ligne qui réalise le gros du travail. \verb|switch[choice]| renvoie un de nos objets fonctions (ou lève une \verb|KeyError|). Ensuite nous exécutons \verb|result()| qui l’appelle.

On peut économiser quelques lignes de code via :
\begin{lstlisting}[language=python]
# appelle une des fonctions
try:
    switch[choice]()
except KeyError:
    print 'I didn\'t understand your choice.'
\end{lstlisting}



\section{Graphiques avec pylab}\index{graphique 2D}
J'utilise le module \gras[module!pylab]{pylab} que j'importe par
\begin{lstlisting}[language=python]
import pylab as pl
\end{lstlisting}

Le principe est le même que pour les graphiques avec matlab. On définit des figures :
\begin{lstlisting}[language=python]
fig = pl.figure()
\end{lstlisting}
Et on peut ensuite y afficher des graphiques, les exporter, modifier les propriétés etc\dots

\begin{remarque}
Si on n'utilise qu'une seule figure, il n'est pas nécessaire de définir son nombre, qui n'est utile que pour pouvoir changer de figure, nettoyer une figure pour la remettre à zéro et afficher autre chose à la place. Par défaut, le numéro est \textbf{1}, et il est automatiquement incrémenté quand on appelle de nouveau cette fonction sans argument.
\end{remarque}

Pour remettre une figure à zéro :
\begin{lstlisting}[language=python]
pl.figure(1) # definit la figure 1 comme figure courante
pl.clf() # efface la figure courante (clf pour clear figure)
\end{lstlisting}

\begin{attention}
Pylab est un module pour manipuler des objets. Si beaucoup de tutoriels ne montrent pas cette façon là de faire, c'est parce qu'il existe des routines internes qui vont déterminer le dernier objet activé (la dernière figure, le dernier graphique, afin d'appliquer les méthodes sur ces objets là, mais la façon propre de manipuler les graphes est de faire des objets. C'est beaucoup plus facile à comprendre et à lire.
\end{attention}


\subsection{Afficher un graphique}
Pour faire un plot
\begin{lstlisting}[language=python]
pl.plot(x,y)
\end{lstlisting}
et l'afficher à l'écran
\begin{lstlisting}[language=python]
pl.show()
\end{lstlisting}

\subsection{Exporter un graphique}
Pour exporter la figure courante, il suffit de faire :
\begin{lstlisting}[language=python]
pl.savefig('ma_figure.png')
pl.savefig('ma_figure.svg')
pl.savefig('ma_figure.pdf')
\end{lstlisting}

\begin{remarque}
L'export en .svg fonctionne très mal je trouve, et j'en veux pour preuve la gestion des textes. En effet, ceux ci apparaissent comme des groupes de chemin, et non comme des caractères d'un texte. J'exporte généralement en .pdf et j'importe le .pdf dans Inkscape quand je souhaite faire des modifications. Même si, pour des pdf, le texte n'est pas facilement modifiable (essayez de modifier un caractère au milieu d'un mot sans supprimer tous les caractères qu'il y a après). Mais c'est bien mieux que la version .svg je trouve. 
\end{remarque}


\subsection{Éviter les fuites mémoires avec pylab}\label{sec:pylab-fuite-memoire}
C'est un problème qui survient quand on génère et affiche des figures dans une boucle par exemple. 

En effet, il faut savoir que pylab (ou matplotlib.pyplot) ne supprime pas les figures par défaut, même en fermant la figure, même en effaçant la figures, l'utilisation mémoire reste. Je dis ça en me basant sur mon expérience, j'ai en effet testé toutes ces méthodes. 

Voici un cas concrêt : 
\begin{lstlisting}[language=python]
for i in range(5):
  fig = pl.figure()
  fig.plot(x,y)
  fig.savefig(name)
\end{lstlisting}

J'ai bien évidemment largement épuré l'exemple, mais c'est pour donner l'idée. La solution, pour ne pas garder en mémoire la figure, c'est d'utiliser l'option : 
\begin{lstlisting}[language=python]
for i in range(5):
  fig = pl.figure()
  fig.hold(False)
  fig.plot(x,y)
  fig.savefig(name)
\end{lstlisting}

\begin{attention}
\begin{verbatim}
pl.hold(False)
\end{verbatim}
ne fonctionne pas chez moi. Il fait bien ce que je veux, à savoir évite les fuites mémoires, mais modifie la présentation des figures (je parle pour des subplots). La méthode que je montre plus haut fonctionne, je l'ai testée.
\end{attention}


\subsection{Plusieurs graphiques sur une même page : subplots}\gras{subplot}
\gras[module!pylab]{pylab} fonctionne comme les plots dans \gras{matlab}. Il existe aussi la possibilité de faire des subplots.

\begin{lstlisting}[language=python]
fig = pl.figure()

# 2 lignes, 3 colonnes pour les subplots
# Le 3e indice sert juste a positionner le subplot dans la matrice ainsi creee, balayant de gauche a droite puis de haut en bas.

# en haut a gauche
plot1 = fig.add_subplot(2, 3, 1)
plot1.plot(x,y)

#en haut au milieu
plot2 = fig.add_subplot(2, 3, 2)
plot2.plot(x,y)

#en haut a droite
plot3 = fig.add_subplot(2, 3, 3)
plot3.plot(x,y)

#en bas a gauche
plot4 = fig.add_subplot(2, 3, 4)
plot4.plot(x,y)

#[...]

pl.show()
\end{lstlisting}

\subsubsection{Ajuster les espaces entre les subplots}
\begin{lstlisting}[language=python]
import pylab as pl
fig = pl.figure()
# default values
# fig.subplots_adjust(left=0.12, bottom=0.1, right=0.90, top=0.90, wspace=0.20, hspace=0.20)
fig.subplots_adjust(left=0.12, bottom=0.1, right=0.96, top=0.96, wspace=0.26, hspace=0.26)
.
.
.
pl.show()
\end{lstlisting}

\begin{itemize}
\item \textbf{left}, \textbf{bottom}, \textbf{right} et \textbf{top} permettent d'ajuster les espaces sur les cotés du graphique (sans toucher aux espaces entre les subplots). À noter que vous ne pouvez pas trop toucher à \textbf{left} et \textbf{bottom} parce que dans cet espace se trouvera la légende certains axes, alors que \textbf{right} et \textbf{top} n'ont normalement aucune légende, vous pouvez donc rogner un peu dans cette partie là.
\item \textbf{wspace} et \textbf{hspace} contrôlent les espaces respectivement horizontaux et verticaux entre les subplots. La valeur spécifier, en pourcentage, représente l'espace à alouer à tous les espaces entre subplots (chaque espace aura une fraction du total.
\end{itemize}

\subsubsection{Ajouter un subplot en coordonnées polaires}
\begin{lstlisting}[language=python]
import pylab as pl
fig = pl.figure()
fig.add_subplot(1, 1, 1, polar=True) # add a polar subplot
\end{lstlisting}

\subsection{Personnalisations diverses}
Pour aller un peu plus loin
\begin{lstlisting}[language=python]
fig = pl.figure(1) # Pour specifier que la figure active est la 1
pl.clf() # pour remettre a zero la figure active
plot1 = fig.add_subplot(1, 1, 1)
plot1.grid(True)
plot1.set_xlabel("abscisse")
plot1.set_ylabel("ordonnee")
plot1.plot(x,y, 'r.', label="y=f(x)")
plot1.plot(x,z, 'b-', label="z=g(x)")
plot1.legend() # afficher la legende
pl.show()
\end{lstlisting}

\subsubsection{Styles de ligne et de point}\label{sec:linestyle}
Sur \reftab{tab:type_ligne} sont représentés quelques types de lignes différents (deux sous-groupes, les lignes et les marqueurs) : 
\begin{table}[htb]
\hfill
\begin{tabular}{|>{\tt}c<{}|c|}
\hline
character & description\\\hline
'-' & solid line style\\\hline
'-~-' & dashed line style\\\hline
'-.' & dash-dot line style\\\hline
':' & dotted line style\\\hline
'.' & point marker\\\hline
',' & pixel marker\\\hline
'o' & circle marker\\\hline
'v' & triangle\_down marker\\\hline
'\textasciicircum' & triangle\_up marker\\\hline
'<' & triangle\_left marker\\\hline
'>' & triangle\_right marker\\\hline
'1' & tri\_down marker\\\hline
'2' & tri\_up marker\\\hline
\end{tabular}
\hfill
\begin{tabular}{|>{\tt}c<{}|c|}
\hline
character & description\\\hline
'3' & tri\_left marker\\\hline
'4' & tri\_right marker\\\hline
's' & square marker\\\hline
'p' & pentagon marker\\\hline
'*' & star marker\\\hline
'h' & hexagon1 marker\\\hline
'H' & hexagon2 marker\\\hline
'+' & plus marker\\\hline
'x' & x marker\\\hline
'D' & diamond marker\\\hline
'd' & thin\_diamond marker\\\hline
'|' & vline marker\\\hline
'\_' & hline marker\\\hline
\end{tabular}\hfill~

\caption{Différents types de ligne ou de marqueurs pour l'affichage de graphique avec pylab. Pour s'en servir, il faut utiliser une commande du style \texttt{pl.plot(x,z, 'b-', label="z=g(x)")} où \og 'b-'\fg signifie qu'on veut une ligne à trait plein bleue .}\label{tab:type_ligne}
\end{table}

Pour tracer une ligne : 
\begin{lstlisting}[language=python]
fig.plot(x, y, linestyle=':')
\end{lstlisting}
en spécifiant le style de la ligne. 

Pour tracer une courbe en ne montrant que les points : 
\begin{lstlisting}[language=python]
fig.plot(x, y, marker='*')
\end{lstlisting}
en spécifiant le style du marqueur. Pour utiliser le marqueur à la place de la ligne, il suffit de spécifier le code du marker sans l'attribut : 
\begin{lstlisting}[language=python]
fig.plot(x, y, '*')
\end{lstlisting}

\subsubsection{Ajouter une grille (majeure/mineure)}
\begin{lstlisting}[language=python]
# We prepare the plot
fig = pl.figure()
# We define a fake subplot that is in fact only the plot.
plot = fig.add_subplot(1, 1, 1)

plot.xaxis.grid(True,which='minor', color='#000000', linestyle=':')
plot.yaxis.grid(True,which='minor', color='#000000', linestyle=':')
plot.xaxis.grid(True,which='major', color='#000000', linestyle='--')
plot.yaxis.grid(True,which='major', color='#000000', linestyle='--')
\end{lstlisting}

Il est possible de modifier la largeur du trait, en plus de la couleur ou du style. Pour la personnalisation de ces paramètres, les valeurs possibles sont les mêmes que d'habitude. Les différents styles de ligne sont répertoriés dans \refsec{sec:linestyle}.

\begin{remarque}
 Quand il n'y a qu'un seul graphique, la commande :
\begin{verbatim}
 plot = fig.add_subplot(1, 1, 1)
\end{verbatim}
est équivalente à 
\begin{verbatim}
 plot = fig.gca()
\end{verbatim}
\end{remarque}


\subsubsection{Changer la taille des labels des axes}
Ceci permet en particulier de changer la taille des labels mineurs par rapports aux labels majeurs :
\begin{lstlisting}[language=python]
# We prepare the plot
fig = pl.figure()
# We define a fake subplot that is in fact only the plot.
plot_hyperfocal = fig.add_subplot(1, 1, 1)

# We change the fontsize of minor ticks label
plot_hyperfocal.tick_params(axis='both', which='major', labelsize=10)
plot_hyperfocal.tick_params(axis='both', which='minor', labelsize=8)
\end{lstlisting}

\subsubsection{Changer la style des labels des axes}
On peut faire beaucoup de choses de ce coté là. Mais en voici deux principales. 

Premièrement, on peut forcer le passage en texte scientifiques, avec des puissances de dix, et on active l'écriture en puissance de 10 au delà de certaines bornes (en dessous de $10^{-3}$ ou au dessus de $10^3$ par exemple) : 
\begin{lstlisting}[language=python]
from matplotlib.ticker import ScalarFormatter
# We prepare the plot
fig = pl.figure()
# We define a fake subplot that is in fact only the plot.
plot = fig.add_subplot(1, 1, 1)

myxfmt = ScalarFormatter(useOffset=True)
myxfmt._set_offset(1e5)
myxfmt.set_scientific(True)
myxfmt.set_powerlimits((-3, 3)) 
plot.xaxis.set_major_formatter(myxfmt)
\end{lstlisting}

\bigskip

Une autre technique très puissante est de spécifier directement le formatteur, de la façon suivante : 
\begin{lstlisting}[language=python]
from matplotlib.ticker import FormatStrFormatter
# We prepare the plot
fig = pl.figure()
# We define a fake subplot that is in fact only the plot.
plot = fig.add_subplot(1, 1, 1)

myxfmt = FormatStrFormatter("%.3g")
plot.xaxis.set_major_formatter(myxfmt)
\end{lstlisting}

Ici j'ai utilisé le formateur spécial \verb|"%.3g"|. Ce dernier n'affichera que 3 chiffres significatifs, extrêmement pratique quand on veut afficher correctement des nombres plus petits que 1, sans avoir des 0 en trop. En particulier pour une échelle log, j'avais donc correctement affiché les valeurs suivante : $0.01$, $0.1$, $1$, $10$, $100$

\subsubsection{Changer la taille du texte d'un graphique}
Afin de changer complètement les caractéristiques pour les graphiques, on peut modifier les paramètres de matplotlib en faisant : 
\begin{lstlisting}[language=python]
from matplotlib import rcParams

rcParams.update({'font.size':15})
\end{lstlisting}

Il y a bien entendu d'autres paramètres, comme le type de police par exemple.

\subsubsection{Légende}
Pour afficher la légende, il faut d'une part spécifier le nom des courbes quand on les déclare : 
\begin{lstlisting}[language=python]
fig = pl.figure()
myplot = fig.add_subplot(1, 1, 1)
myplot.plot(x,y, 'r.', label="y=f(x)")
myplot.plot(x,z, 'b-', label="z=g(x)")
\end{lstlisting}
mais il faut aussi dire qu'on veut afficher la légende :
\begin{lstlisting}[language=python]
myplot.legend()
\end{lstlisting}

\bigskip

On peut spécifier la position de la légende via le paramètre optionnel \texttt{loc} qui peut prendre les valeurs suivantes :
'best' (only implemented for axis legends), 'upper right' , 'upper left' , 'lower left' , 'lower right' , 'right' , 'center left' , 'center right', 'lower center', 'upper center', 'center'.

que l'on utilise de la façon suivante :
 \begin{lstlisting}[language=python]
myplot.legend(loc='lower right')
\end{lstlisting}


\subsubsection{Utilisation de symbole au lieu de ligne}
\begin{lstlisting}[language=python]
myplot.plot(x,z, 'o', markersize=5)
\end{lstlisting}
On peut utiliser des cercles \texttt{o}, des croix \texttt{x} ou des carrés \texttt{s}

Il existe beaucoup d'options de personnalisation, pour avoir des symboles sans couleur de remplissage mais en contrôlant la couleur du trait du marqueur notamment. La liste n'est pas exhaustive : 
\begin{verbatim}
markerfacecolor='None' # To set 'no color' inside the marker
markeredgewidth=1
markeredgecolor='#000000'
\end{verbatim}

\bigskip

On peut aussi utiliser des marqueurs, et des lignes. qu'on peut définir soit via :
\begin{lstlisting}[language=python]
myplot.plot(x,z, '--o')
\end{lstlisting}
ou via
\begin{lstlisting}[language=python]
myplot.plot(x,z, linestyle='--', marker='o')
\end{lstlisting}

\subsubsection{Ajouter du texte}
\begin{lstlisting}[language=python]
myplot.text(x, y, "mon texte")
\end{lstlisting}
permet d'ajouter du texte en spécifiant les coordonnées dans les unités des axes, tandis que
\begin{lstlisting}[language=python]
pl.figtext(x, y, "mon texte")
\end{lstlisting}
permet de spécifier les coordonnées en unités absolues de la figure, c'est à dire que (0,0) correspond au coin en bas à gauche, et (1, 1) au coin en haut à droite de la fenêtre graphique.

\subsubsection{Tracer des poligones et formes diverses}
J'ai souhaité récemment tracer des rectangles avec python, pour rajouter des informations sur un graphique. La commande suivante permet de le faire :
\begin{lstlisting}[language=python]
fig = pl.figure()
myplot = fig.add_subplot(1, 1, 1)

x_left = 1
x_right = 2
y_bottom = 3
y_top = 4

myplot.fill([x_left, x_right, x_right, x_left],[y_bottom, y_bottom, y_top, y_top], fill=False, hatch='\\')
\end{lstlisting}

Il y a aussi une fonction pour tracer des rectangles, à partir du point en bas à gauche, de la largeur et de la hauteur du rectangle : 
\begin{lstlisting}[language=python]
from matplotlib.patches import Rectangle

fig = pl.figure()
myplot = fig.add_subplot(1, 1, 1)

x = 1
y = 2
width = 3
height = 4

rect = Rectangle((x, y), width, height, color='#dddddd', label="Self Shadowing")

myplot.add_patch(rect)
\end{lstlisting}

\bigskip

\gras{Line2D}, \gras{Arrow} sont aussi des fonctions intéressantes dans \textbf{matplotlib.lines} et \textbf{matplotlib.patches}
respectivement. 

Il est possible de forcer l'apparition de ces objets même en dehors de la zone de plot avec l'option : 
\begin{verbatim}
clip_on=False
\end{verbatim}

\bigskip

Une autre possibilité est de changer les coordonnées. C'est à dire qu'on peut soit spécifier les coordonnées dans les axes des
données, du graphique (auquel cas, le coin en bas à gauche a pour coordonnée (0,0) et celui en haut à droite (1,1)), de la
figure (même chose que pour le graphique mais d'un bord à l'autre de la fenêtre graphique).

Pour cela, il faut utiliser l'option \gras{transform} qui vaudra l'une des trois valeurs suivante selon qu'on veut les axes des
données (par défaut), du graphique ou de la fenêtre graphique : 
\begin{verbatim}
fig = pl.figure()
plot_orbits = fig.add_subplot(1, 1, 1)

transform = plot_orbits.transData
transform = plot_orbits.transAxes
transform = fig.transFigure
\end{verbatim}


\subsubsection{Titre de graphique}
Pour donner un titre à un graphique, il suffit d'utiliser la commande : 
\begin{lstlisting}[language=python]
fig = pl.figure()
fig.suptitle("evolution of y in function of x")
\end{lstlisting}

\subsection{Manipuler les axes}

\subsubsection{Lier les limites des axes entre elles dans subplot}\index{subplot!lier les axes}
Dans des graphiques subplots, on peut de plus lier les axes entre eux, pour que lors d'un zoom dans la fenêtre graphique affichée avec \texttt{pl.show()}, le même zoom soit reproduit dans tous les axes liés.

\begin{lstlisting}[language=python]
# en haut a gauche
myplot1 = fig.add_subplot(2, 1, 1)
myplot1.plot(x,y)

#en haut au milieu
myplot2 = fig.add_subplot(2, 1, 2, sharex=myplot1, sharey=myplot1)
myplot2.plot(x,y)

pl.show()
\end{lstlisting}

\begin{remarque}
On peut bien évidemment ne partager que l'axe des x ou l'axe des y, et c'est extrêmement pratique dans certains cas, quand par exemple on affiche plusieurs variables en fonction du temps.
\end{remarque}

\subsubsection{Récupérer les bornes des axes}
Avec la commande ci-dessous, on peut récupérer les valeurs extrêmes des axes, utile pour le placement d'objets, ou avoir des traits qui font toute la largeur des courbes.
\begin{lstlisting}[language=python]
ylims = current_plot.get_ylim()
\end{lstlisting}

\subsubsection{Zoom et étendue des axes}

Pour spécifier le zoom sur la figure, il faut rajouter :
\begin{lstlisting}[language=python]
pl.axis([xmin, xmax, ymin, ymax])
\end{lstlisting}

Python ne va pas forcément zoomer sur les limites du graphique. Je veux dire par là que si la valeur maximale en abscisse est 3, il affichera peut-être des limites jusqu'à 5. Pour forcer à avoir une zone graphique qui affiche nos courbes et uniquement nos courbes, il faut utiliser :
\begin{lstlisting}[language=python]
pl.axis('tight')
\end{lstlisting}

et comme je suis pointilleux et jamais content, j'aime bien que les axes commencent à zéro, ce qu'on peut faire via :
\begin{lstlisting}[language=python]
fig = pl.figure()
myplot = fig.add_subplot(1, 1, 1)
myplot.axis('tight')
myplot.set_xlim(xmin=0)
myplot.set_ylim(ymin=0)
\end{lstlisting}

Les commandes \textbf{xlim} et \textbf{ylim} peuvent spécifier respectivement les limites (\textbf{xmin}, \textbf{xmax}) et (\textbf{ymin}, \textbf{ymax}) des axes. En ne spécifiant qu'une valeur, l'autre est laissée inchangée.

\subsubsection{Même zoom sur les deux axes}
Parfois, il est utile que le zoom soit le même sur les deux axes. En particulier si on veut qu'un cercle ressemble à un cercle (si les deux axes ont des zoom différents, ça ressemblera à une ellipse. 

Il y a plusieurs manières de faire ça, notamment en définissant directement le paramètre dans un subplot. Mais voici une méthode générale qui marche bien par défaut : 
\begin{lstlisting}[language=python]
pl.axis('equal')
\end{lstlisting}


\subsection{Styles de graphiques 2D}
\subsubsection{Graphiques logarithmiques}

À la place de \verb|plot| on peut aussi faire :
\begin{lstlisting}[language=python]
fig = pl.figure()
myplot = fig.add_subplot(1, 1, 1)
myplot.semilogx(x,y)
myplot.semilogy(x,y)
myplot.loglog(x,y)
\end{lstlisting}

\subsubsection{Histogrammes}
Pour afficher un histogramme :
\begin{lstlisting}[language=python]
myplot.hist(x, normed=True, bins=20)
\end{lstlisting}

Pour afficher plusieurs histogrammes à la fois :
\begin{lstlisting}[language=python]
myplot.hist([x,y], normed=True, bins=20, label=['x', 'y'])
\end{lstlisting}

\bigskip

On peut changer le style avec \verb|histtype='style'| où \verb|style| peut prendre les valeurs suivantes :
\begin{itemize}
\item bar
\item barstacked
\item step
\item stepfilled
\end{itemize}

D'autres options pratiques sont :
\begin{lstlisting}[language=python]
cumulative=True
normed=True
bins=20
\end{lstlisting}

\begin{attention}
Quand on veut afficher plusieurs histogrammes dans le même plots en plusieurs fois, il faut spécifier un range de bins bien définis. J'ai déjà fait deux groupes de deux histogrammes, et j'avais de gros soucis dans les valeurs, ceci dû à ces bins qui affichaient les mêmes valeurs mais qui au final ne correspondaient pas aux mêmes choses.
\end{attention}

\subsubsection{Barres d'erreurs}
Il existe un style graphique uniquement pour représenter des données avec des barres d'erreurs. Il faut tout de même savoir que la valeur spécifiée correspond à la demi largeur de la barre (la même taille sera appliquée à gauche et à droite de la valeur de référence)

Pour faire des barres d'erreurs il faut faire : 
\begin{lstlisting}[language=python]
fig = pl.figure()
myplot = fig.add_subplot(1, 1, 1)
myplot.errorbar(x, y, yerr=e, fmt='ro')
\end{lstlisting}
où $e$ est une liste de même taille que $x$ et $y$ et qui contient les demi-largeurs des barres d'erreurs. \texttt{xerr} permet de faire la même choses pour des barres d'erreurs horizontales, et les deux options sont utilisables simultanément.

\bigskip

Pour faire des barres d'erreurs assymétriques, il suffit de spécifier une liste de deux listes : 
\begin{lstlisting}[language=python]
myplot.errorbar(x, y, yerr=[e,f], fmt='ro')
\end{lstlisting}

\subsection{Afficher une carte de valeurs (du 3D avec le z représenté par un code de couleur)}
On peut afficher une matrice et spécifier des axes (par défaut, il n'affiche que les indices de la matrice, mais on peut associer des plages de valeurs arbitraires aux axes x et y)

\begin{lstlisting}[language=python]
liste_x = range(5)
liste_y = range(5)

import pylab as pl
fig = pl.figure()
myplot = fig.add_subplot(1, 1, 1)
myplot.set_xlabel("axe des x")
myplot.set_ylabel("axe des y")

myplot.matshow(matrice, fignum=1)
fig.colorbar()

myplot.set_xticks(range(len(liste_x)))
myplot.set_xticklabels(liste_x)
myplot.set_yticks(range(len(liste_y)))
myplot.set_yticklabels(liste_y)
pl.show()
\end{lstlisting}

\section{Faire des statistiques}
\subsection{Bases}
Dans \gras{numpy}, il existe les fonctions statistiques de bases, notamment la \gras[moyenne]{valeur moyenne} et l'\gras{écart-type} :
\begin{lstlisting}[language=python]
import numpy as np
a = range(10)
np.mean(a)
np.std(a)
\end{lstlisting}



\subsection{Test de Kolmogorov-Smirnov}
Pour celà, il faut utiliser le module suivant :
\begin{lstlisting}[language=python]
import scipy.stats.stats as scss
\end{lstlisting}
et on appelle le test via
\begin{lstlisting}[language=python]
(d_value, p_value) = scss.ks_2samp(a,b)
\end{lstlisting}
où $a$ et $b$ sont deux échantillons de données (des listes ou des array quoi).





\section{Exécuter des commandes système}
Le module \gras[python!os]{os} permet d'utiliser plusieurs commandes systèmes dont voici quelques équivalents

\begin{tabular}{>{\bfseries}r<{}@{ : }p{11cm}}
commande bash & équivalent python\\
cd 'dossier' & os.chdir('nom dossier')\\
mkdir & os.mkdir('dossier')\\
ls & os.listdir('.')\\
pwd & os.getcwd()\\
rm 'fichier.txt' & os.remove('fichier.txt')
\end{tabular}

Une commande permet de manière plus générale de lancer une commande système :
\begin{lstlisting}[language=python]
os.system('cmd argument')
\end{lstlisting}

Par exemple, on peut très bien faire les commandes précédentes via la commande system
\begin{lstlisting}[language=python]
# methode 1
os.system('cd \'dossier\'')
# methode 2
os.system("cd 'dossier'")

os.system("mkdir 'dossier'")
os.system("ls")
os.system("pwd")
os.system("rm 'fichier.txt'")
\end{lstlisting}

Dans ce même module, il existe une commande très pratique pour tester l'existence d'un fichier ou dossier (pratique pour tester avant suppression ou changement de répertoire, ça évite les bugs du programme)
\begin{lstlisting}[language=python]
nom_fichier = "simulation.log"
if os.path.exists(nom_fichier):
  os.remove(nom_fichier)
\end{lstlisting}


Si, par contre, on désire stocker le résultat d'une commande, on ne peut utiliser \texttt{system}. On doit utiliser un autre module, le module \gras[python!commands]{commands} et utiliser la commande suivante
\begin{lstlisting}[language=python]
liste = commands.getoutput("ls")
# facultatif mais utile
liste = liste.split("\n")
\end{lstlisting}

\begin{attention}
Préférer les méthodes décrites dans \refsec{sec:subprocess} plutôt que les méthodes du module \gras[module!os]{os}. Je sais plus pourquoi, mais parait que c'est mieux.
\end{attention}

\section{Erreurs}
\subsection{Unindent}
\begin{lstlisting}[language=python]
IndentationError: unexpected indent
\end{lstlisting}

C'est normalement dû au fait qu'il y a dans le code source des indentations avec tabulation et espaces. Un simple rechercher/remplacer permet de corriger l'erreur normalement.

\subsection{Pointeurs implicites}
Attention avec python, il va parfois utiliser des pointeurs implicites, et la modification d'une valeur va en modifier plusieurs. L'exemple classique est de dire que la liste b est égale à la liste a :
\begin{lstlisting}[language=python]
>>> a = range(5)
>>> b = a
>>> b.append(6)
>>> print(a)
[0, 1, 2, 3, 4, 6]
\end{lstlisting}

Pour contourner le problème, on fera :
\begin{lstlisting}[language=python]
>>> a = range(5)
>>> b = list(a)
>>> b.append(6)
>>> print(a)
[0, 1, 2, 3, 4]
\end{lstlisting}

\bigskip

Mais il peut y avoir plus subtil. J'ai récemment eu le problème suivant :
\begin{lstlisting}[language=python]
>>> toto = [[]] * 5
[[], [], [], [], []]
>>> toto[1].append(1)
>>> print(toto)
[[1], [1], [1], [1], [1]]
\end{lstlisting}

Pour contourner le problème, j'ai fait :
\begin{lstlisting}[language=python]
>>> toto = [[] for i in range(5)]
[[], [], [], [], []]
>>> toto[1].append(1)
>>> print(toto)
[[], [1], [], [], []]
\end{lstlisting}

\section{Astuces}
\subsection{Copier un fichier}
En utilisant le module \gras[module!shutil]{shutil}, on peut copier un fichier à l'aide de la commande suivante 
\begin{lstlisting}[language=python]
>>> import shutil
>>> shutil.copy2(src, dst)
\end{lstlisting}

\subsection{Copier une liste (et non faire un lien virtuel)}
Par défaut, en python, si vous assignez une variable contenant une liste à une autre variable, la 2e variable sera un lien virtuel vers la première. La conséquence la plus importante est que si vous modifiez la 2e variable, vous modifiez également la première.

\begin{exemple}
\begin{lstlisting}[language=python]
>>> t1 = range(5)
>>> t2 = t1
>>> print t1, t2
[0, 1, 2, 3, 4] [0, 1, 2, 3, 4]
>>> del(t2[2])
>>> print t1, t2
[0, 1, 3, 4] [0, 1, 3, 4]
\end{lstlisting}
\end{exemple}

Afin d'éviter ce genre de problèmes, on peut faire les choses suivantes :
\begin{lstlisting}[language=python]
t2 = list(t1)
\end{lstlisting}
ou
\begin{lstlisting}[language=python]
t2 = t1[:]
\end{lstlisting}

\subsection{Exécuter une portion de code python à partir d'une chaîne de caractères}
Une fonction très pratique est la fonction \texttt{eval}. Elle permet de dire à python de considérer le contenu d'une variable ou expression comme si c'était du code python. Un exemple concrêt :
\begin{lstlisting}[language=python]
a = 2
b = 'a'
print eval(b)
\end{lstlisting}

On voit rapidement les possibilités de cette commande dans des boucles et autres joyeusetées.

\subsection{Lister des dossiers}
La commande suivante permet de lister tous les dossiers du répertoire courant :
\begin{lstlisting}[language=python]
list_dirs = [dir for dir in os.listdir(".") if os.path.isdir(dir)]
\end{lstlisting}

\subsection{Supprimer toutes les occurences d'un caractère dans une chaine}
Il existe une méthode particulière de \textbf{String} qui peut être utilisée pour faire celà. Par défaut, cette méthode permet de faire des remplacements de caractères, et optionnellement d'en supprimer certains, mais dans le cas présent, on ne fait que supprimer des caractères : 
\begin{lstlisting}[language=python]
>>> test = "toto"
>>> test.translate(None, 'o')
'tt'
>>> print(test)
'toto'
\end{lstlisting}

\subsection{Tester si une variable existe}
\begin{lstlisting}[language=python]
try:
  print toto
except NameError:
  print "toto n'existe pas"
\end{lstlisting}

ou alors

utiliser la méthode \texttt{has\_key()} des dictionnaires internes répertoriant les variables. Si on veut tester l'existence de la variable $x$  qui est une variable locale ou globale, il faut utiliser respectivement
\begin{lstlisting}[language=python]
vars().has_key('x')
globals().has_key('x')
\end{lstlisting}

ou encore
\begin{lstlisting}[language=python]
if ('x' in vars()):
  print("'x' est defini")
if ('x' in locals()):
  print("'x' est une variable locale")
\end{lstlisting}

\subsection{Tester si un fichier ou dossier existe}
\begin{lstlisting}[language=python]
if os.path.isfile("test.txt") :
  print("le fichier existe")
\end{lstlisting}

De même, la commande \verb|os.path.isdir()| permet de tester si un dossier existe :
\begin{lstlisting}[language=python]
if os.path.isdir("test") :
  print("le dossier existe")
\end{lstlisting}

\subsection{Tester le type d'une variable}\label{sec:test-type-variable}
\begin{lstlisting}[language=python]
>>> liste=['test', 'test']
>>> if (type(liste) == list):
...  print "c'est une liste"
"c'est une liste"
\end{lstlisting}

On peut aussi tester plusieurs types à la fois
\begin{lstlisting}[language=python]
>>> liste=['test', 'test']
>>> if (type(liste) in (list,int)):
...  print "c'est une liste ou un entier"
"c'est une liste ou un entier"
\end{lstlisting}

Pour connaître le type à rentrer pour le test, il suffit de faire
\begin{lstlisting}[language=python]
>>> liste=['test', 'test']
>>> type(liste)
<type 'list'>
\end{lstlisting}
Le type à rentrer est simplement la valeur entre guillemets, donc ici \texttt{list}

\subsection{Arrondir les floats}\index{arrondis}
Il est possible d'arrondir les floats à l'aide de
\begin{lstlisting}[language=python]
>>> test = 1.12456124
>>> round(test,3)
1.12499999
\end{lstlisting}

On pourrait croire que ceci ne marche pas. En fait, c'est dû au fait que le processeur arrondi à la valeur la plus proche qu'il connait (penser au fait qu'un ordinateur ne connait pas les réels par défaut).

Si on ne veut que quelques chiffres significatifs, c'est généralement pour un affichage. On n'a alors aucun problème, car lors de la conversion en string du flottant arrondi, il restera les bons chiffres significatifs (à condition qu'on ait fait un round avant, ça va de soi)
\begin{lstlisting}[language=python]
>>> test = 1.12456124
>>> test2 = round(test,3)
>>> str(test2)
'1.125'
\end{lstlisting}

\subsection{Lister un type de fichier}
En console, il est possible de lister des types de fichier en utilisant les expressions régulières, comme par exemple
\begin{lstlisting}[language=python]
ls *.txt
ls test*
\end{lstlisting}

Avec python, si on souhaite faire ça dans un processus, il faudra utiliser
\begin{lstlisting}[language=python]
process = subprocess.Popen("ls *.txt", shell=True)
\end{lstlisting}

En effet, \verb|process = subprocess.Popen(["ls", "*.txt"])| renverra une erreur. Ne me demandez pas pourquoi, j'en sais rien.

\begin{remarque}
Pour récupérer la sortie, il faut bien évidemment faire comme expliqué dans la section \refsec{sec:subprocess}.
\end{remarque}

\subsection{Modifier la ligne précédemment affichée dans le terminal (progression)}	
\begin{lstlisting}[language=python]
import sys, time
 
for i in range(1, 6):
  sys.stdout.write("%d %% \r" % i))
  sys.stdout.flush()
  time.sleep (1)
\end{lstlisting}

Le caractère \verb|\r| est équivalent de chr(13). Mais c'est plus facile et plus lisible de se servir de \verb|\r| je trouve.

\begin{remarque}
Quelques petites explications :

Par défaut quand on fait un \textbf{print} en console, le \textbf{print} envoi en fin de ligne un \texttt{chr(13)} (Carriage Return ; \touche{CR}) et un \texttt{chr(10)}, (Line Feed ; \touche{LF}).

\touche{CR} (\texttt{chr(13)}) renvoi en début de ligne et \touche{LF} effectue un saut de ligne. La combinaison de ces deux caractères équivaut à un renvoi à la ligne (qui sous GNU/Linux se code \touche{CR}+\touche{LF}).
\end{remarque}

\bigskip

Il faut quand même comprendre une chose importante, c'est que \verb|\r| permet de retourner au début de la ligne, mais il faut impérativement que le nombre de caractère soit le même ou supérieur, sous peine d'avoir les caractères des lignes précédentes toujours apparents. 

Faites un test : 
\begin{lstlisting}[language=python]
import sys
 
sys.stdout.write("Hello World\r")
sys.stdout.flush()

sys.stdout.write("Goodbye")
sys.stdout.flush()
\end{lstlisting}

Une petite astuce consiste à mettre des espaces en fin de ligne pour ``nettoyer'' les éventuels extra caractères des lignes précédentes :
\begin{lstlisting}[language=python]
import sys
 
sys.stdout.write("Hello World\r")
sys.stdout.flush()

sys.stdout.write("Goodbye       ")
sys.stdout.flush()
\end{lstlisting}


\bigskip

Cette technique est pratique pour afficher des barres de progression dans le terminal, afin de bien voir que le script calcule, où il en est, quand il met beaucoup de temps à tourner et qu'on ne sait pas trop si ça se passe bien ou s'il bugue quelque part.
\begin{lstlisting}[language=python]
import sys
 
for instant_index in range(NB_LAST_POINTS,max_lengths,TIME_DELAY):
  
  # We display a progress bar of the computation
  # The extra spaces are to make sure that no old character from the previous line will appear
  sys.stdout.write("Progression %6.2f %% : %i / %i        \r" % ((instant_index * 100. / float(max_lengths)), instant_index, max_lengths))
  sys.stdout.flush()
  
  # Some calculation
  # [...]
\end{lstlisting}



\subsection{Personnaliser Python}
Cette astuce doit surement fonctionner avec d'autres language, je  n'ai utilisé que python, donc à vous de voir comment généraliser.

Je souhaitais pouvoir exécuter certains scripts python depuis  n'importe quel répertoire sans avoir à entrer le chemin complet. je  souhaitais aussi pouvoir importer les modules que j'ai créé sans  devoir modifier le \texttt{sys.path} à chaque fois et dans chaque  script.

Afin de pouvoir exécuter les scripts depuis n'importe quel dossier,  il faut déjà regrouper tous ces scripts dans un dossier particulier.  Par exemple, j'ai mis dans mon \texttt{/home} un dossier \texttt {python/traitement\_simu} où je stocke les scripts que je veux  exécuter pour chaque simulation, et un dossier \texttt{python/modules} où je stocke tous mes modules.

Les modifications sont à effectuer dans \texttt{.bash\_profile}.

Il faut rajouter le dossier \texttt{python/traitement\_simu} dans la  variable PATH et il faut créer une variable PYTHONPATH.

\begin{attention}
Afin que ceci fonctionne, il faut \emph{exporter} ces variables.
\end{attention}

En supposant que votre fichier \texttt{.bash\_profile} est vide (ou  n'existe pas.\footnote{Ce fichier est à placer dans votre \texttt{/home}}), voici ce qu'il faut rajouter :
\begin{lstlisting}[language=python]
PATH=$PATH:$HOME/python/traitement_simu
PYTHONPATH=$HOME/python/modules

export PATH PYTHONPATH
\end{lstlisting}

\subsection{Récupérer des infos à partir du chemin absolu}
À l'aide du module \gras{os}, on peut manipuler le chemin d'un fichier ou dossier. 

On peut par exemple récupérer le nom du dossier courant (sans le chemin) :
\begin{lstlisting}[language=python]
CWD_name = os.path.basename(os.getcwd()) # The name of the current directory
\end{lstlisting}

Il existe aussi les méthodes \textbf{os.path.dirname} et \textbf{os.path.pardirb}.

\subsection{Récupérer le nom ou l'extension d'un fichier}
Il existe une méthode dans le module \gras{os}
\begin{lstlisting}[language=python]
ext = os.path.splitext(file_name)[1]
name = os.path.splitext(file_name)[0]
\end{lstlisting}
ou 
\begin{lstlisting}[language=python]
(name, ext) = os.path.splitext(file_name)
\end{lstlisting}



\subsection{Optimisations}
(J'ai eu la flemme de traduire, mais l'idée y est)

If you feel the need for speed, go for built-in functions - you can't beat a loop written in C. Check the library manual for a built-in function that does what you want. If there isn't one, here are some guidelines for loop optimization:

\begin{itemize}
\item Rule number one: only optimize when there is a proven speed bottleneck. Only optimize the innermost loop. (This rule is independent of Python, but it doesn't hurt repeating it, since it can save a lot of work. :-)
\item Small is beautiful. Given Python's hefty charges for bytecode instructions and variable look-up, it rarely pays off to add extra tests to save a little bit of work.
\item Use intrinsic operations. An implied loop in map() is faster than an explicit for loop; a while loop with an explicit loop counter is even slower.
\item Avoid calling functions written in Python in your inner loop. This includes lambdas. In-lining the inner loop can save a lot of time.
\item Local variables are faster than globals; if you use a global constant in a loop, copy it to a local variable before the loop. And in Python, function names (global or built-in) are also global constants!
\item Try to use map(), filter() or reduce() to replace an explicit for loop, but only if you can use a built-in function: map with a built-in function beats for loop, but a for loop with in-line code beats map with a lambda function!
\item Check your algorithms for quadratic behavior. But notice that a more complex algorithm only pays off for large N - for small N, the complexity doesn't pay off. In our case, 256 turned out to be small enough that the simpler version was still a tad faster. Your mileage may vary - this is worth investigating.
\item And last but not least: collect data. Python's excellent profile module can quickly show the bottleneck in your code. if you're considering different versions of an algorithm, test it in a tight loop using the time.clock() function. 
\end{itemize}

\section{Avancé}
\subsection{Passer des arguments à un script}
Il y a un moyen très simple de passer des arguments à un script python en ligne de commande. Il suffit de faire par exemple :
\begin{verbatim}
> ./test.py 1 "hey"
\end{verbatim}

Le script alors contenir les commandes suivantes :
\begin{lstlisting}[language=python]
import sys

print sys.argv[1] # affiche arg1
print sys.argv[2] # affiche arg2
\end{lstlisting}
Les arguments sont des chaînes de caractères, à vous de les convertir dans le format qui vous convient en fonction de l'ordre.

\begin{remarque}
À noter que le premier élément de la liste \textbf{sys.argv} est le chemin absolu vers le script
\begin{verbatim}
(Pdb) print sys.argv
['/home/login/scripts/test.py', '1', 'hey']
\end{verbatim}
\end{remarque}

\bigskip

Il est possible de faire des choses beaucoup plus compliquées en mettant des options au script du style \texttt{-d} ou \texttt{--debut} mais c'est beaucoup plus compliqué. Il faut pour cela importer le module \textbf{getopt}. Voici un bout de code que j'avais fait en utilisant ce module : 
\begin{lstlisting}[language=python]
import sys, getopt

try:                                
    opts, args = getopt.getopt(sys.argv[1:], 
    "hdf", ["help", "debut=", "fin="])
except getopt.GetoptError:          
    print("les options sont h, d et f")                        
    sys.exit(2)

for opt, arg in opts:                
    if opt in ("-h", "--help"):      
        print("les options sont h, d et f")                    
        sys.exit()                  
    elif opt in ("-d", "--debut"):
        try:
            indice_simu_debut = int(arg)
        except:
            print("L'argument n'est pas un entier")
    elif opt in ("-f", "--fin"): 
        try:
            indice_simu_fin = int(arg)
        except:
            print("L'argument n'est pas un entier")

autres_arguments = " ".join(args)
\end{lstlisting}
On peut remarquer que chaque option a un format court et un format long.

\section{Bugs}
\subsection{Fuite mémoire}
Pour l'instant, le seul cas que j'ai eu se trouve être dû à pylab, voir \refsec{sec:pylab-fuite-memoire}.

\printindex
\end{document}