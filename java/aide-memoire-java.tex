\documentclass[a4paper,twoside]{article}
\usepackage{autiwa}

\title{Aide mémoire Java}
\author{Autiwa}

\makeindex
\begin{document}

\tableofcontents

\clearpage

\section{Préambule}
Java est un language orienté objet, il n'est pas possible d'y couper. Dans toute la suite, il sera supposé que vous connaissez déjà le principe de la Programmation Orienté Objet (POO). 

En Java, l'exécution d'un programme va lancer la méthode \textbf{main()} de l'objet associé. Le code ci-dessous est le code minimum d'un programme Java qui défini la classe \textbf{sdz1}. Ce code ne fait rien. 
\begin{lstlisting}[language=java]
public class sdz1 {

  /**
  * @param args
  */

  public static void main(String[] args) {
  // TODO Auto-generated method stub

  }
}
\end{lstlisting}

Le même code, affichant le sempiternel ``Hello World'' : 
\begin{lstlisting}[language=java]
import java.util.Scanner;


public class sdz1 {

  /**
    * @param args
    */
  public static void main(String[] args) {
    // TODO Auto-generated method stub
    
    System.out.println("Hello World!");
  }

}
\end{lstlisting}

Quelques informations de base : 
\begin{itemize}
\item Le programme commence par le lancement de la méthode \textbf{.main()} de la classe du programme principal.%TODO 
\item Les lignes doivent se terminer par ``\textbf{;}''
\item Il faut déclarer les variables avant de les utiliser (voir \refsec{sec:types_variables})
\item Il faut compiler le programme avant de pouvoir l'utiliser (via une plateforme java, ce n'est pas un binaire mais un bytecode utilisable uniquement par un environnement Java)
\end{itemize}


\section{Les bases}
\subsection{Commentaires}
Il existe deux types de commentaires : 
\begin{itemize}
\item les commentaires unilignes : introduits par les symboles \textbf{//}, ils mettent tous ce qui les suit en commentaires, du moment que le texte se trouve sur la même ligne que les \textbf{//}.
\begin{lstlisting}[language=java]
public static void main(String[] args){
  //Un commentaire
  //un autre
  //Encore un autre
  Ceci n'est pas un commentaire ! ! ! !
}
\end{lstlisting}


\item les commentaires multilignes : ils sont introduits par les symboles \textbf{/*} et se terminent par les symboles \textbf{*/}.
\begin{lstlisting}[language=java]
public static void main(String[] args){
 
  /*
  Un commentaire
  Un autre
  Encore un autre
  */
  Ceci n'est pas un commentaire ! ! 
}
\end{lstlisting}
\end{itemize}

\subsection{Types de variables}\label{sec:types_variables}
En Java, nous avons deux type de variables :
\begin{itemize}
\item des variables de type simple ou "primitif",
\item des variables de type complexe ou encore des objets.
\end{itemize}

Ce qu'on appelle des types simples, ou types primitifs, en Java ce sont tout bonnement des nombres entiers, des nombres réels, des booléens ou encore des caractères. Mais vous allez voir qu'il y a plusieurs façons de déclarer certains de ces types.

Commençons par les variables de type numérique
\begin{itemize}
\item Le type \gras[type!byte]{byte} (1 octet) peut contenir les entiers entre -128 et +127.
\begin{lstlisting}[language=java]
byte temperature;
temperature = 64;
\end{lstlisting}

\item Le type \gras[type!short]{short} (2 octets) contient les entiers compris entre -32768 et +32767.
\begin{lstlisting}[language=java]
short vitesseMax;
vitesseMax = 32000;
\end{lstlisting}

\item Le type \gras[type!int]{int} (4 octets) va de -2*109 à 2*109 (2 et 9 zéros derrière... ce qui fait déjà un joli nombre).
\begin{lstlisting}[language=java]
int temperatureSoleil;
temperatureSoleil = 15600000;
\end{lstlisting}
C'est en kelvins...

\item Le type \gras[type!long]{long}(8 octets) de -9*1018 à 9*1018 (encore plus gros...).
\begin{lstlisting}[language=java]
long anneeLumiere;
anneeLumiere = 9460700000000000;
\end{lstlisting}

\item Le type \gras[type!float]{float} (4 octets) correspond à des nombres avec virgule flottante.
\begin{lstlisting}[language=java]
float pi;
pi = 3.141592653f;
\end{lstlisting}
ou encore
\begin{lstlisting}[language=java]
float nombre;
nombre = 2.0f;
\end{lstlisting}

Vous remarquerez que nous ne mettons pas de virgule mais un point ! Et vous remarquerez aussi que même si le nombre en question est rond, on met tout de même .0 derrière celui-ci !

\item Le type \gras[type!double]{double} (8 octets) est identique à float, si ce n'est qu'il contient un nombre plus grand derrière la virgule.
\begin{lstlisting}[language=java]
double division;
division = 0.333333333333333333333333333333333333333333334;
\end{lstlisting}
\end{itemize}


Nous avons aussi des variables stockant du caractère

Le type \gras[type!char]{char} contient UN caractère stocké entre de simples quotes ' ' comme ceci...
\begin{lstlisting}[language=java]
char caractere;
caractere = 'A';
\end{lstlisting}

\bigskip

Nous avons aussi le type booléen

Le type \gras[type!boolean]{boolean} qui lui contient \textbf{true} (vrai) ou \textbf{false} (faux).
\begin{lstlisting}[language=java]
boolean question;
question = true;
\end{lstlisting}

\subsubsection{Chaînes de caractères}
Et aussi le type \gras[type!String]{String}. Celle-ci correspond à de la chaîne de caractères.
Ici, il ne s'agit pas d'une variable mais d'un objet qui instancie une classe qui existe dans Java ; nous pouvons l'initialiser en utilisant l'opérateur unaire new() dont on se sert pour réserver un emplacement mémoire à un objet (mais nous reparlerons de tout ceci dans la partie deux, lorsque nous verrons les classes), ou alors lui affecter directement la chaîne de caractères.

Vous verrez que celle-ci s'utilise très facilement et se déclare comme ceci :
\begin{lstlisting}[language=java]
String phrase;
phrase = "Titi et gros minet";
//Deuxieme methode de declaration de type String
String str = new String();
str = "Une autre chaine de caracteres";
//La troisieme
String string = "Une autre chaine";
//Et une quatrieme pour la route
String chaine = new String("Et une de plus ! ");
\end{lstlisting}

\bigskip

String étant un objet, il possède des méthodes afin de les manipuler. En voici quelques exemples :
\begin{itemize}

\item \gras{toLowerCase()}

Cette méthode permet de transformer toute saisie clavier de type caractère en minuscules. Elle n'a aucun effet sur les nombres, puisqu'ils ne sont pas assujettis à cette contrainte. Vous pouvez donc utiliser cette fonction sur une chaîne de caractères comportant des nombres.
Elle s'utilise comme ceci :
\begin{lstlisting}[language=java]
String chaine = new String("COUCOU TOUT LE MONDE !");
String chaine2 = new String();
chaine2 = chaine.toLowerCase();//donne "coucou tout le monde !"
\end{lstlisting}


\item \gras{toUpperCase()}

Celle-là est facile, puisqu'il s'agit de l'opposée de la précédente. Elle transforme donc une chaîne de caractères en majuscules. Et s'utilise comme suit :
\begin{lstlisting}[language=java]
String chaine = new String("coucou coucou"), chaine2 = new String();
chaine2 = chaine.toUpperCase();//donne "COUCOU COUCOU"
\end{lstlisting}


\item \gras{concat()}

Très explicite, celle-là permet de concaténer deux chaînes de caractères.
\begin{lstlisting}[language=java]
String str1 = new String("Coucou "), str2 = new String("toi !");
String str3 = new String();
str3 = str1.concat(str2);//donne "Coucou toi !"
\end{lstlisting}


\item \gras{length()}

Celle-là permet de donner la longueur d'une chaîne de caractères (en comptant les espaces blancs).
\begin{lstlisting}[language=java]
String chaine = new String("coucou ! "); 
int longueur = 0;
longueur = chaine.length();//donne 9
\end{lstlisting}


\item \gras{equals()}

Permet de voir si deux chaînes de caractères sont identiques. Donc, de faire des tests. C'est avec cette fonction que vous ferez vos tests de conditions, lorsqu'il y aura des \gras[type!String]{String}. Exemple concret :
\begin{lstlisting}[language=java]
String str1 = new String("coucou"), str2 = new String("toutou");
 
if (str1.equals(str2))//Si les deux chaines sont identiques
        System.out.println("Les deux chaines sont identiques !");
 
else
        System.out.println("Les deux chaines sont differentes !");
\end{lstlisting}


Vous pouvez aussi demander la non vérification de l'égalité grâce à l'opérateur de négation \og !\fg, ce qui nous donne :
\begin{lstlisting}[language=java]
String str1 = new String("coucou"), str2 = new String("toutou");
 
if (!str1.equals(str2))//Si les deux chaines sont differentes
        System.out.println("Les deux chaines sont differentes !");
 
else
        System.out.println("Les deux chaines sont identiques !");
\end{lstlisting}

Le principe de ce genre de condition fonctionne de la même façon pour les boucles. Et dans l'absolu, cette fonction retourne un booléen. C'est pourquoi nous pouvons utiliser cette fonction dans les tests de condition.
\begin{lstlisting}[language=java]
String str1 = new String("coucou"), str2 = new String("toutou");
boolean Bok = str1.equals(str2);//ici Bok prendra la valeur false
\end{lstlisting}

\item \gras{charAt()}

Le résultat de cette méthode sera un caractère, car il s'agit d'une méthode d'extraction de caractères, je dirais même d'UN caractère. Elle ne peut s'opérer que sur des \gras[type!String]{String}! Elle possède la même particularité que les tableaux, c'est-à-dire que, pour cette méthode, le premier caractère sera le numéro 0. Cette méthode prend un entier comme argument.
\begin{lstlisting}[language=java]
String nbre = new String("1234567");
char carac = ' ';
carac = nbre.charAt(4);//renverra ici le caractere 5
\end{lstlisting}


\item \gras{substring()}

Comme son nom l'indique, elle permet d'extraire une sous-chaîne de caractères d'une chaîne de caractères. Cette méthode prend 2 entiers comme arguments. Le premier définit le début de la sous-chaîne à extraire inclus, le deuxième correspond au dernier caractère à extraire exclus. Et le premier caractère est aussi le numéro 0.
\begin{lstlisting}[language=java]
String chaine = new String("la paix niche"), chaine2 = new String();
chaine2 = chaine.substring(3,13);//permet d'extraire "paix niche"
\end{lstlisting}


\item \gras{indexOf()}/\gras{lastIndexOf()}

\gras{indexOf()} permet d'explorer une chaîne de caractères depuis son début. \gras{lastIndexOf()} depuis sa fin, mais renvoie l'index depuis le début de la chaine. Elle prend un caractère, ou une chaîne de caractères comme argument, et renvoie un int. Tout comme \gras{charAt()} et \gras{substring()}, le premier caractère est à la place 0. Je crois qu'ici un exemple s'impose, plus encore que pour les autres fonctions :
\begin{lstlisting}[language=java]
String mot = new String("anticonstitutionnellement");
int n = 0;
 
n = mot.indexOf('t');      // n vaut 2
n = mot.lastIndexOf('t');        // n vaut 24
n = mot.indexOf("ti");    // n vaut 2
n = mot.lastIndexOf("ti");      // n vaut 12
n = mot.indexOf('x');      // n vaut -1
\end{lstlisting}
\end{itemize}

\subsubsection{Astuces}
On peut très bien compacter la phase de déclaration et d'initialisation en une seule phase ! Comme ceci :
\begin{lstlisting}[language=java]
int entier = 32;
float pi = 3.1416f;
char carac = 'z';
String mot = new String("Coucou");
\end{lstlisting}

Et lorsque nous avons plusieurs variables d'un même type, nous pouvons compacter tout ceci en une déclaration comme ceci :
\begin{lstlisting}[language=java]
int nbre1 = 2, nbre2 = 3, nbre3 = 0;
\end{lstlisting}

\bigskip

On peut aussi convertir une variable ou une formule dans un autre type de donnée via ce qu'on appelle un \textbf{cast} :
\begin{lstlisting}[language=java]
int i = 123;
double j = (double)i;
\end{lstlisting}

\begin{attention}
Il peut y avoir des pertes de précision au sein même des opérations mathématiques que la conversion du résultat via un cast n'empêchera pas. 
Ex :
\begin{lstlisting}[language=java]
int i = 123, j = 5;
double k = (double) (i / j);
\end{lstlisting}
\end{attention}




\subsection{Entrées/Sorties}
\subsubsection{Entrées}
Afin de récupérer ce qu'on tape au clavier, il faut importer une nouvelle classe
\begin{lstlisting}[language=java]
import java.util.Scanner;
\end{lstlisting}

\bigskip

Voici l'instruction pour permettre à Java de récupérer ce que vous avez saisi et ensuite de l'afficher :
\begin{lstlisting}[language=java]
Scanner sc = new Scanner(System.in);
System.out.println("Veuillez saisir un mot :");
String str = sc.nextLine();
System.out.println("Vous avez saisi : " + str);
\end{lstlisting}

\bigskip

Dans le cas où on récupère autre chose qu'une chaîne de caractère, il faut vider la ligne via un \texttt{sc.nextLine();} avant de chercher à récupérer une chaîne de caractère.
\begin{lstlisting}[language=java]
Scanner sc = new Scanner(System.in);

System.out.println("Saisissez un entier : ");
int i = sc.nextInt();

System.out.println("Saisissez une chaine : ");
//On vide la ligne avant d'en lire une autre
sc.nextLine();
String str = sc.nextLine();
System.out.println("FIN ! ");
\end{lstlisting}


%TODO voir les sorties

\subsection{Boucles}
\subsubsection{Boucle if}\index{boucle!if}
\begin{lstlisting}[language=java]
if(//condition)
  {
  // execution des instructions si la condition est remplie
  
  
  }
else
  {
  // execution des instructions si la condition n'est pas remplie
  
  
  }
\end{lstlisting}

\begin{exemple}
\begin{lstlisting}[language=java]
int i = 10;
 
if (i < 0)
  System.out.println("Le nombre est negatif");
 
else
  System.out.println("Le nombre est positif");
\end{lstlisting}
\end{exemple}

\begin{remarque}
On n'est pas obligés de mettre les accolades quand il n'y a qu'une seule ligne d'instruction dans la boucle.
\end{remarque}

\bigskip

On peut aussi mettre des tests multiples :


\begin{lstlisting}[language=java]
int i = 0;

if (i < 0)
  System.out.println("Ce nombre est negatif !");      

else if(i > 0)
  System.out.println("Ce nombre est positif !!");           

else  
  System.out.println("Ce nombre est nul !!");
\end{lstlisting}

Si on souhaite faire beaucoup de tests, on peut souhaiter utiliser la structure \gras[boucle!switch]{switch} à la place.

\subsubsection{Boucle Switch}\index{boucle!switch}

\begin{lstlisting}[language=java]
int nbre = 5; 

switch (nbre)
{
  case 1: 
    System.out.println("Ce nombre est tout petit");
    break;

  case 2: 
    System.out.println("Ce nombre est tout petit");
    break;

  case 3: 
    System.out.println("Ce nombre est un peu plus grand");
    break;

  case 4: 
    System.out.println("Ce nombre est un peu plus grand");
    break;

  case 5: 
    System.out.println("Ce nombre est la moyenne");
    break;

  case 6: 
    System.out.println("Ce nombre est tout de meme grand");
    break;

  case 7: 
    System.out.println("Ce nombre est grand");
    break;

  default: 
    System.out.println("Ce nombre est compris entre 8 et 10");

}
\end{lstlisting}

\subsubsection{Opérateur ternaire}
La particularité des conditions ternaires réside dans le fait que trois opérandes (variable ou constante) sont mises en jeu mais aussi que ces conditions sont employées pour affecter des données dans une variable. Voici à quoi ressemble la structure de ce type de condition :
\begin{lstlisting}[language=java]
int x = 10, y = 20;
int max = (x < y) ? y : x ; //Maintenant max vaut 20
\end{lstlisting}

On peut faire par exemple : 
\begin{lstlisting}[language=java]
int x = 10;
String type = (x % 2 == 0) ? "C' est pair" : "C' est impair" ; 
//Ici type vaut "C' est pair"

x = 9;
type = (x % 2 == 0) ? "C' est pair" : "C' est impair" ; 
//Ici type vaut "C' est impair"
\end{lstlisting}

\subsubsection{Boucle while}\index{boucle!while}
\begin{lstlisting}[language=java]
int a = 1, b = 15;
while (a < b)
{
        System.out.println("coucou " +a+ " fois !!");
        a++;
}
\end{lstlisting}

On peut aussi faire :
\begin{lstlisting}[language=java]
//Une variable vide
String prenom;
// On initialise celle-ci a O pour oui !
char reponse = 'O';
//Notre objet Scanner, n'oubliez pas l'import de java.util.Scanner
Scanner sc = new Scanner(System.in);
//Tant que la reponse donnee est egale a oui
while (reponse == 'O')
{
  //On affiche une instruction
  System.out.println("Donnez un prenom : ");
  //On recupere le prenom saisi
  prenom = sc.nextLine();
  // On affiche notre phrase avec le prenom
  System.out.println("Bonjour " +prenom+ " comment vas-tu ?");
  //On demande si la personne veut faire un autre essai
  System.out.println("Voulez-vous reessayer ?(O/N)");
  //On recupere la reponse de l'utilisateur
  reponse = sc.nextLine().charAt(0);
}
 
System.out.println("Au revoir...");
//Fin de la boucle
\end{lstlisting}

\subsubsection{Boucle do while}\index{boucle!do while}
\begin{lstlisting}[language=java]
do{
  blablablablablablablabla
}while(a < b);
\end{lstlisting}

\subsubsection{Boucle for}\index{boucle!for}
\begin{lstlisting}[language=java]
for(int i = 1; i <= 10; i++)
{
  System.out.println("Voici la ligne "+i);
}
\end{lstlisting}

\bigskip

On peut aussi boucler sur les éléments d'un tableau :
\begin{lstlisting}[language=java]
String tab[] = {"toto", "titi", "tutu", "tete", "tata"};
 
for(String str : tab)
   System.out.println(str);
\end{lstlisting}\index{tableaux}

Cette forme de boucle for est particulièrement adaptée au parcours de tableau. On peut naturellement se demander comment faire de même pour des tableaux multidimensionnels. La chose à retenir est que la variable en premier paramètre de la boucle for doit être du même type que la valeur de retour du tableau. Dans le cas d'un tableau multi-dimensionnel, cette dernière sera un tableau de dimension inférieure. En conséquence, on peut boucler sur des sous tableaux, puis sur les éléments de ces derniers via des boucles imbriquées :
\begin{lstlisting}[language=java]
String tab[][] = {{"toto", "titi", "tutu", "tete", "tata"}, 
                  {"1", "2", "3", "4"}};
int i = 0, j = 0;

for(String sousTab[] : tab)
{
  i = 0;
  for(String str : sousTab)
  {     
    System.out.println("La valeur de la nouvelle boucle est : " + str);
    System.out.println("La valeur du tableau a l'indice [" 
      + j + "][" +i +"] est : " +  tab[j][i] + "\n");
    i++;
  }
  j++;
}
\end{lstlisting}





\subsection{Tableaux}\index{tableaux}
On définit des tableaux de la même manière que les éléments qui le constituent. Un tableau a donc un type associé et ne peut stocker que des éléments de ce type là.

Pour définir un tableau sans l'initialiser on fait :
\begin{lstlisting}[language=java]
int tableauEntier[] = new int[6];
//ou encore
int[] tableauEntier2 = new int[6];
\end{lstlisting}
mais la définition d'un tableau initialisé se fait elle de la façon suivante :
\begin{lstlisting}[language=java]
String tableauChaine[] = {"chaine1", "chaine2", "chaine3" , "chaine4"};
\end{lstlisting}

\bigskip

On peut définir des tableaux multi-dimensionnels : 
\begin{lstlisting}[language=java]
int premiersNombres[][] = { {0,2,4,6,8},{1,3,5,7,9} };
\end{lstlisting}

Nous voyons bien ici les deux lignes de notre tableau symbolisées par les doubles crochets \texttt{[][]}. Ce genre de tableau n'est rien d'autre que plusieurs tableaux en un. Ainsi, pour passer d'une ligne à l'autre, nous jouerons avec la valeur du premier crochet.
\begin{exemple}
\verb|premiersNombres[0][0]| correspondra au premier élément de la colonne paire.\\
Et \verb|premiersNombres[1][0]| correspondra au premier élément de la colonne impaire.
\end{exemple}

\subsubsection{Propriétés}
La longueur d'un tableau \textbf{tab} est donnée par :
\begin{lstlisting}[language=java]
tab.length
\end{lstlisting}

\section{Les classes}
Toute classe possède un constructeur (une méthode particulière, lancée lors de l'initialisation d'une instance de classe), ayant le même nom que la classe elle-même.

Prenons un exemple avec une classe \textbf{Ville} :
\begin{lstlisting}[language=java]
public class Ville{
  /**
  * Stocke le nom de notre ville
  */
  String nomVille;
  /**
  * Stocke le nom du pays de notre ville
  */
  String nomPays;
  /**
  * Stocke le nombre d'habitants de notre ville
  */
  int nbreHabitant;
 
  /**
   * Constructeur par defaut
   */
  public Ville(){
    System.out.println("Creation d'une ville !");      
    nomVille = "Inconnu";
    nomPays = "Inconnu";
    nbreHabitant = 0;
  }
 
}
\end{lstlisting}

\begin{remarque}
Il est possible de surcharger le constructeur et ainsi avoir plusieurs constructeurs en fonction des paramètres passés lors de l'initialisation de l'instance de classe.
\end{remarque}

\bigskip

Dans l'exemple précédent, les variables de classes sont publiques et modifiables directement. La philosophie de la POO est d'utiliser des accesseurs getVar (qui renvoient la valeur d'une variable var) et des mutateurs setVar (qui modifient la valeur de la variable var). En conséquence, on mettra plutôt les variables avec une portée privée, et on créera des méthodes permettant d'afficher ou modifier ces dernières. La classe devient alors :
\raggedbottom
\begin{lstlisting}[language=java]
public class Ville {
  /**
  * Stocke le nom de notre ville
  */
  private String nomVille;
  /**
  * Stocke le nom du pays de notre ville
  */
  private String nomPays;
  /**
  * Stocke le nombre d'habitants de notre ville
  */
  private int nbreHabitant;

  /**
  * Constructeur par defaut
  */
  public Ville(){
    System.out.println("Creation d'une ville !");          
    nomVille = "Inconnu";
    nomPays = "Inconnu";
    nbreHabitant = 0;
  }
 
  /**
  * Constructeur d'initialisation
  * @param pNom 
  *                    Nom de la Ville
  *  @param pNbre
  *                    Nombre d'habitants
  *  @param pPays
  *                    Nom du pays
  */
  public Ville(String pNom, int pNbre, String pPays)
  {
    System.out.println("Creation d'une ville avec des parametres !");     
    nomVille = pNom;
    nomPays = pPays;
    nbreHabitant = pNbre;
  }
  
 //************************************************************************
  //                                    ACCESSEURS
  //***********************************************************************
  
  /**
   * Retourne le nom de la ville
   * @return le nom de la ville
   */
  public String getNom()
  {
    return nomVille;
  }
  
  /**
   * Retourne le nom du pays
   * @return le nom du pays
   */
  public String getNomPays()
  {
    return nomPays;
  }
  
  /**
   * Retourne le nombre d'habitants
   * @return nombre d'habitants
   */
 public int getNombreHabitant()
 {
    return nbreHabitant;
 }
 
 //************************************************************************
 //                                    MUTATEURS
 //************************************************************************
 
 /**
  * Definit le nom de la ville
  * @param pNom
  *             nom de la ville
  */
 public void setNom(String pNom)
 {
    nomVille = pNom;
 }
 
 /**
  * Definit le nom du pays
  * @param pPays
  *             nom du pays
  */
 public void setNomPays(String pPays)
 {
    nomPays = pPays;
 }
 
 /**
  * Definit le nombre d'habitants
  * @param nbre
  *             nombre d'habitants
  */
  public void setNombreHabitant(int nbre)
  {
    nbreHabitant = nbre;
  }
  
}
\end{lstlisting}
\flushbottom

La création d'une instance de classe se fait via le mot clé \textbf{new} :
\begin{lstlisting}[language=java]
Ville bordeaux = new Ville();
\end{lstlisting}

\bigskip

Il y a deux principaux types de variables : 
\begin{itemize}
\item Les variables de classes, qui sont définies dans la classe, avec l'attribut \gras{static}. Cette variable sera commune à toutes les instances de la classe.
\begin{lstlisting}[language=java]
public class Ville {
 
  /**
   * Variable de classe
   */
  static String nomVille;
\end{lstlisting}
\item Les variables d'instance, qui sont définies dans la classe. Cette variable \textbf{var} est accessible, à l'intérieur de la classe via \textbf{this.var} où \textbf{this} désigne l'instance de classe (c'est un concept de POO difficile à saisir, car c'est abstrait, ça désigne la variable instanciée, que l'on ne connait pas \textit{a priori} lorsque l'on programme. En gros, si je défini une variable toto, de type \og la classe considérée\fg, \textbf{this} désigne, DANS la variable toto, l'instance toto de la classe.
\begin{lstlisting}[language=java]
public class Ville {
 
  /**
   * Variable d'instance
   */
  String nomVille;
\end{lstlisting}
\end{itemize}

On peut créer des variables privées (notamment pour faire des variables locales) en rajoutant un attribu privé à une variable.

\subsection{Méthodes de classe}

\begin{figure}[htb]
\centering
\includegraphics[width=\linewidth]{figures/method_scheme.pdf}
\caption{Explication des différents attributs d'une méthode. Le but ici est de présenter à quoi correspond la syntaxe, sans présenter les différents choix possibles.}
\end{figure}

Les méthodes ne sont pas limitées en nombre de paramètres (s'il n'y a pas d'argument, il faut au minimum \og \texttt{String[] args}\fg.

Il existe trois grands types de méthodes : 
\begin{itemize}
\item celles qui ne renvoient rien. Elles sont de type \gras{void}. Ces types de méthodes n'ont pas d'instruction \textbf{return} !
\item celles qui retournent des types primitifs (\gras[type!double]{double}, \gras[type!int]{int}...). Elles sont de type \gras[type!double]{double}, \gras[type!int]{int}, \gras[type!char]{char}... Celles-ci ont une instruction \textbf{return}.
\item celles qui retournent des objets. Par exemple, une méthode qui retourne un objet de type \gras[type!String]{String}. Celles-ci aussi ont une instruction \textbf{return}.
\end{itemize}

\bigskip

\begin{remarque}
On n'imbrique pas les méthodes et elles doivent toutes faire partie d'une classe. 
\end{remarque}

\begin{attention}
Les méthodes de la classe \textbf{main}, c'est à dire la classe lancée par défaut au début du programme et qui contient le \gras{main()}, doivent être \gras{static}
\end{attention}

\subsection{La surcharge de méthode}
La surcharge de méthode consiste à garder un nom de méthode (donc un type de traitement à faire, pour nous, lister un tableau) et de changer la liste ou le type de ses paramètres.

Nous allons surcharger notre méthode afin qu'elle puisse travailler avec des int par exemple :
\begin{lstlisting}[language=java]
static void parcourirTableau(String[] tab)
  {
     for(String str : tab)
        System.out.println(str);
  }
        
static void parcourirTableau(int[] tab)
  {
     for(int str : tab)
        System.out.println(str);
  }
\end{lstlisting}

On peut aussi faire de même avec les tableaux à 2 dimensions ou ajouter des paramètres à la méthode.




\printindex
\end{document}