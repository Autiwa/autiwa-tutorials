\documentclass[a4paper,twoside]{article}
\usepackage{autiwa}
\usepackage{listings}
% \lstset{language=Fortran,
% basicstyle=\ttfamily\small,
% columns=flexible}
% \lstset{keywordstyle=\color{blue}\bfseries}

\title{Aide mémoire Fortran 90}
\author{Autiwa}

\newcommand{\raccourci}[1]{{\bfseries #1}}


\makeindex
\begin{document}

\tableofcontents

\clearpage

\section{Préambule}
Ceci est un tutoriel fortran 90, il a pour but de donner des astuces de programmations, des bonnes pratiques, présenter ce qui se faisait en fortran 77 et qu'il ne faut plus faire. 

Dans la suite on considèrera le format libre, c'est à dire que les lignes peuvent avoir jusqu'à 132 caractères.

\section{Compilation}
Le compilateur traduit les instructions qui ont été tapées par le programmeur et produit, si aucune erreur n'a été faite, en langage machine. La traduction est placée dans un fichier objet dont le nom est identique à celui du fichier source, mais dont l'extension est cette fois .o sous UNIX. Ceci est schématisé sur \reffig{fig:compilation}

\begin{attention}
Dans certains cas, l'éditeur de liens est automatiquement appelé et rend le programme exécutable.
\end{attention}

\begin{figure}[htb]
\centering
\includegraphics[width=0.65\linewidth]{figure/compilation.pdf}
\caption{La compilation de tous les fichiers source doit se faire avant l'édition des liens pour créer le fichier exécutable.}\label{fig:compilation}
\end{figure}

L'application complète comportera tous les modules liés. Tout d'abord, il conviendra de compiler séparément sans édition des liens chaque module. À l'issue de cette opération, on obtiendra des modules objets, c'est à dire en langage machine, mais sans adresse d'implantation en mémoire. On les reliera tout en fixant les adresses à l'aide de l'éditeur de liens. Le fichier obtenu sera le programme exécutable. Ceci est schématisé sur \reffig{fig:compilation_modulaire}

\begin{figure}[htb]
\centering
\includegraphics[width=0.65\linewidth]{figure/compilation_modulaire.pdf}
\caption{Dans le cas présent, on doit compiler le module point, puis compiler le module planète, puis compiler le module système, et enfin compiler le programme qui fait appel au module système. La compilation d'un fichier source doit se faire \emph{après} la compilation de tous les modules dont il dépend.}\label{fig:compilation_modulaire}
\end{figure}

\begin{attention}
La compilation d'un fichier source doit se faire \emph{après} la compilation de tous les modules dont il dépend.
\end{attention}


\section{Transition fortran 77/fortran 90}
\subsection{Instructions obsolètes ou dépréciées}

\begin{center}
\begin{tabular}{ll}
Obsolètes & Déprécié\\
IF arithmétique & format fixe\\
GO TO assigné & COMMON\\
RETURN multiple & DATA au milieu des inst.\\
FORMAT assigné & BLOCK DATA\\
DO sur une même instruc. & EQUIVALENCE\\
Index réel de boucle DO & GO TO calculé\\
branchement sur END IF & INCLUDE\\
PAUSE & ENTRY\\
descripteur H & DOUBLE PRECISION\\
 & Instructions Fonction\\
 & SEQUENCE\\
 & DO WHILE
\end{tabular}
\end{center}

\section{Les bases}
\subsection{Éléments de syntaxe}
Une ligne ne peut dépasser 132 caractères. Il est possible cependant d'étendre une instruction de plus de 132 caractères sur plusieurs lignes.

Pour continuer une ligne, en cas de ligne trop longue : 
\begin{lstlisting}[language=Fortran]
print *, 'Montant HT :', montant_ht, & 
  'TVA:',tva	,&
  'Montant TTC :', montant_ttc
\end{lstlisting}

\bigskip

Pour continuer une chaîne de caractère par contre, il faut impérativement utiliser deux caractères \og \& \fg : 
\begin{lstlisting}[language=Fortran]
print *, 'Entrez un nombre entier & 
	&compris entre 100 & 199'
\end{lstlisting}

\bigskip

Les commentaires commencent par le symbole \og ! \fg : 
\begin{lstlisting}[language=Fortran]
if (n < 100 .or. n > 199) ! Test cas d'erreur
! On lit l'exposant
read *,x 
! On lit la base
read *,y 
if (y <=0) then ! Test cas d'erreur 
  print *, 'La base doit etre un nombre > 0'
else 
  z = y**x ! On calcule la puissance
end if
\end{lstlisting}

\bigskip

\textbf{Les identificateurs.} On appelle identificateurs, les noms des variables, des fonctions, des
sous-programmes... Ils obéissent aux règles suivantes :
\begin{itemize}
\item ils sont composés de lettres (les 26 lettres de l'alphabet) et de chiffres (de 0 à 9) dont la totalité ne peut dépasser 31 caractères.
\item ils commencent obligatoirement par une lettre.
\item le symbole \og souligné\fg (\_) est un caractère utilisable par les identificateurs (à ne pas confondre avec le signe moins : \og -\fg).
\item il n'y a pas de distinction entre les minuscules et les majuscules.
\end{itemize}

\subsection{Déclaration de variables}
Le premier bloc d'instructions d'un programme source est composé de la suite de déclaration des types des différentes variables utilisées dans le programme. En fait, Fortran ne rend pas obligatoire les déclarations de type. Si une variable commence par i, j, k, l, m ou n, Fortran 90 considère par défaut que cette variable est entière. Nous déconseillons cependant fortement d'utiliser un typage implicite qui est source de nombreuses erreurs de calcul. Il est donc conseillé de commencer chaque programme par l'instruction \textbf{implicit none} qui rend obligatoire la déclaration du type de toutes les variables. Si une ou plusieurs variables ne sont pas déclarées, le compilateur retournera un message d'erreur.

La syntaxe de déclaration des variables est la suivante : 
\begin{lstlisting}[language=Fortran]
type [,attribut] :: liste_variables
\end{lstlisting}
\begin{itemize}
\item \texttt{type} est le nom du type de variable (integer, real, double precision, complex, logical, character)
\item \texttt{attribut} est une liste d'attributs optionnels (parameter, dimension, allocatable, intent,\dots)
\item \texttt{liste\_variables} est la liste des variables que l'on déclare comme ayant ce type.
\end{itemize}

\begin{exemple}
\begin{lstlisting}[language=Fortran]
program declaration
       
implicit none          
integer ::          i, j=5           ! type entier
real ::             var, x=2.5       ! type reel simple precision 
double precision :: plus_precis      ! type reel double precision 
logical ::          reussite         ! type logique 
character (10) ::   mot              ! type caractere
complex ::          z = (1.2, 20)    ! type complexe
   
[...]                      ! bloc d'instructions executables
      
end
\end{lstlisting}
\end{exemple}

Le type \texttt{logical} n'admet que deux valeurs \texttt{.true.} ou \texttt{.false.}

\begin{remarque}
Il est possible, voire recommande, d'écrire la déclaration des variables sur plusieurs lignes afin d'en faciliter la lisibilité et d'ajouter des commentaires.

\begin{lstlisting}[language=Fortran]
program commentaires 
 
implicit none
integer :: i, &       ! indice de boucle sur le temps
           j, &       ! nombre de niveaux  
           k          ! indice de boucle sur les niveaux 
    
[...]            ! bloc d'instructions executables
  
end
\end{lstlisting}
\end{remarque}

\subsection{Afficher et lire des informations (entrée et sortie standard)}
Pour pouvoir écrire des informations à l'écran, c'est-à-dire des commentaires ou le contenu de certaines variables, on utilise l'instruction print. L'affectation d'une variable par l'intermédiaire du clavier se fait en utilisant l'instruction read. Si on ne veut pas imposer le format d'écriture (on laisse faire l'ordinateur), on utilise le format par défaut symbolisé par une * (voir l'exemple du programme ecriture-lecture). Tous les caractères compris entre ' ' (ou entre ” ”) sont écrits à l'écran.

\begin{lstlisting}[language=Fortran]
program ecriture_lecture
implicit none
real :: var, &
	lu	! variable lue au clavier

var = 2.5

print*, 'La variable var vaut : ', var
print*, 'Entrez une valeur au clavier'
read*, lu
print*, 'La valeur entree au clavier est', lu

end
\end{lstlisting}

\subsection{Les expressions arithmétiques}
On retrouve les opérateurs arithmétiques usuels : \og + \fg, \og - \fg, \og * \fg et \og / \fg. Ces opérandes ne sont définis à priori que lorsque les deux opérandes sont de même type. Le résultat est du même type que les opérandes. 

Le compilateur convertit le type de l'un des opérandes, lorsque ces derniers sont différents, pour effectuer l'opération. Les conversions se font suivant la hiérarchie suivante : entier $\rightarrow$ réel $\rightarrow$ double précision. En présence d'un opérande entier et d'un opérande réel, l'entier est transformé en réel. 

\subsubsection{Cas de la division}
Ainsi le quotient de deux entiers et un entier : 
\begin{align}
\frac{5}{2} &= 2 & \frac{3}{5} &= 0
\end{align}

En revanche :
\begin{align}
\frac{5.0}{2.0} &= 2.5 \frac{5.0}{2} = \frac{5}{2.0} = 2.5
\end{align}

\subsubsection{L'opérateur d'élévation à la puissance}

L'opérateur d'élévation à la puissance se note "**". L'expression \texttt{a**b} correspond à la notation mathé\-ma\-tique $a^{b}$. 

Le résultat de l'expression \texttt{a**b} est entier si $a$ et $b$ sont entiers, sinon le résultat est réel.

Soit $b$ un entier positif, 
\begin{align}
a**b &= a*a*\ldots*a \text{ (\emph{b} fois)}\\
a**(-b) &= 1/(a**b)
\end{align}

Pour $b$ réel quelconque et $a$ positif,
\begin{align}
a**b &= exp(b*ln(a))
\end{align}

\subsection{Les expressions logiques}
Pour comparer deux expressions, Fortran 90 dispose de 6 opérateurs de comparaison, \og $<$\fg, \og $<=$\fg, \og $>$\fg, \og $>=$\fg, \og $==$\fg, \og $/=$\fg qui signifient respectivement, inférieur à, inférieur ou égal à, supérieur à, supérieur ou égal à, égal à, différent de. 

\begin{itemize}
\item Lorsque les deux expressions à comparer ne sont pas du même type, Fortran convertit le résultat de l'une des expressions dans le type de l'autre suivant les règles décrites précédemment.

\item Il faut éviter d'utiliser la comparaison entre expressions non 
entières : l'expression logique ($a == 0.0$) avec $a$ réel n'a pas grande 
signification ! 
\end{itemize}

Fortran dispose aussi d'opérateurs logiques permettant de 
combiner des opérateurs de compa\-rai\-son qui sont, par ordre de 
priorité décroissante : \og .not. \fg, \og .and. \fg, \og .or. \fg. Ils ont une 
priorité inférieure aux opérateurs précédents. 

Par exemple :
\begin{align}
y = (\mbox{.not.}(a<b)) &\equiv y = (a>=b) 
\end{align}

La variable $y$ est de type \texttt{logical}. Les parenthèses ne sont 
pas obligatoires mais facilitent la lecture (notez les points 
obligatoires de part et d'autre de \texttt{not},\texttt{and} et \texttt{or}).

\subsection{Les expressions constantes}\label{sec:constantes}
Lorsqu'une constante est utilisée plusieurs fois dans un programme (par exemple $\pi$), il est utile (et recommandé) de la définir une seule fois en début de programme pendant la déclaration des variables.
 
Deux syntaxes sont possibles :
\begin{lstlisting}[language=Fortran]
integer :: nb = 5
real :: PI = 3.141593
\end{lstlisting}
Dans ce cas les variable \emph{nb} et \emph{PI} peuvent être modifiées dans le programme.

\begin{lstlisting}[language=Fortran]
integer, parameter :: nb = 5
real, parameter :: PI = 3.141593
\end{lstlisting}
\emph{nb} et \emph{PI} sont alors des constantes symboliques dont les valeurs ne peuvent pas être modi\-fiées durant le programme (le compilateur affiche un message d'erreur s'il trouve dans le corps du programme l'instruction \texttt{nb = 12} par exemple).

Les déclarations de constante symbolique se font avant toute autre déclaration. On peut aussi utiliser une expression constante dans la mesure ou le compilateur peut la calculer. 

\begin{lstlisting}[language=Fortran]
implicit none
  
integer, parameter ::   nb = 5
integer, parameter ::   nb_max = 2*nb+4
integer, parameter ::   nb_min = 2*nb-4
integer, parameter ::   nb_elem = nb_max - nb_min + 1

[...]        ! bloc d'instructions executables 

end
\end{lstlisting}

\subsection{Les instructions de contrôle}
\subsubsection{L'instruction \emph{if} structuré}

La forme la plus générale du \texttt{if} structuré peut être 
schématisée comme suit :
\begin{lstlisting}[language=Fortran]
if (exp_log1) then
    bloc1     ! bloc d'instructions 
[else if (exp_log2) then 
    bloc2     ! bloc d'instructions 
]...
[else
    blocn     ! bloc d'instructions 
] 
end if
\end{lstlisting}
où \emph{exp\_log} est une expression quelconque de type \texttt{logical} (par exemple : \texttt{if (a $>$= 0) then} ), \emph{bloc} est un bloc d'instruc\-tions, \mbox{[ ]} signifie que le contenu est facultatif, \mbox{[ ]\ldots} signifie que le contenu peut apparaître plusieurs fois. Dans l'exemple ci-dessus, si l'expression \emph{exp\_log1} est vraie alors la suite d'instruc\-tions \emph{bloc1} est exécutée. 

Sinon, si l'expression \emph{exp\_log2} est vraie alors c'est la suite d'instruction \emph{bloc2} qui est exécutée (et ainsi de suite). Enfin, si toutes les expressions précédentes (\emph{exp\_log1}, \emph{exp\_log2}, \ldots) sont fausses et si l'instruction \texttt{else} est présente, la suite d'instructions \emph{blocn} est exécutée. Si l'instruc\-tion \texttt{else} est absente, il est possible qu'aucune instruction ne soit exécutée par un bloc \texttt{if}.

\begin{remarque}
Il est recommandé d'indenter (décaler les blocs d'instructions vers la droite d'un certain nombre de caractères blancs) les différents \texttt{if} afin d'assurer cette lisibilité. 
\end{remarque}



Un exemple d'utilisation du \texttt{if} structuré est donné dans l'exemple ci-après. 
\begin{lstlisting}[language=Fortran]
program nom_if

implicit none

integer :: i, j

read*, i, j

if (i < 0) then
  print*, 'i est negatif'
else if (i > 0) then
  print*, 'i est positif'
else
  if (j < 0) then
      print*, 'j est negatif'
  else if (j > 0) then
      print*, 'j est positif'
  else
      print*, 'i et j sont nuls'
  end if
end if

end
\end{lstlisting}

\subsubsection{L'instruction \emph{select case}}

La syntaxe générale est la suivante : 
\begin{lstlisting}[language=Fortran]
select case (exp_scal) 
[case (selecteur1)
    bloc1     ! bloc d'instructions 
[case (selecteur2)
    bloc2     ! bloc d'instructions
]... 
end select [nom]
\end{lstlisting}
où \emph{exp\_scal} est une expression de type \texttt{integer}, \texttt{logical} ou \texttt{character}. \emph{selecteur} est une valeur, un intervalle de valeurs ou une liste de valeurs de même type que \emph{exp\_scal}.

Cette instruction permet d'exécuter la suite d'instructions \emph{bloc1} lorsque la valeur de l'expression \emph{exp\_scal} est égale au \emph{selecteur} (ou dans l'intervalle donné par le \emph{selecteur}). Les intervalles sont de la forme suivante : \texttt{[valeur1]:valeur2} ou \texttt{valeur1:[valeur2]} (par exemple \texttt{case(1:)} signifie que l'on s'intéresse aux valeurs entières comprises entre 1 et 2147483647. Les sélecteurs peuvent faire appel à des expressions constantes. Les valeurs figurant dans les différents sélecteurs d'une même instruction \texttt{select case} ne doivent pas se recouper (cela engendre une erreur à la compilation).

\begin{lstlisting}[language=Fortran]
program case

implicit none

character(3) :: reponse

print*, 'Voulez-vous continuer le programme ?'
read*, reponse

select case (reponse)
  case ('oui')
    print*, 'OK, ca roule...'
  case ('non')
    print*, 'Au revoir !'
    stop
  case default
    print*, 'Veuillez repondre par "oui" ou par "non"'
end select

end
\end{lstlisting}

\subsubsection{La boucle for}
La syntaxe générale est la suivante :
\begin{lstlisting}[language=Fortran]
do var = debut, fin, [pas] 
  bloc     ! bloc d'instructions 
end do
\end{lstlisting}

La variable de contrôle \emph{var} est de type \texttt{integer} ainsi que les expressions \emph{debut}, \emph{fin} et \emph{pas}.

Cette instruction permet de répéter le bloc d'instructions \emph{bloc} en donnant successivement à la variable \emph{var} les valeurs \emph{debut}, \emph{debut+pas}, \ldots, \emph{fin}. Si \emph{pas} est absent, il est par défaut égal à 1. La valeur de \emph{pas} peut être négative. Il faut alors que \emph{debut} soit plus grand que \emph{fin} sinon aucune instruction de \emph{bloc} ne sera effectuée. 

\begin{attention}
Il n'est pas possible de modifier, dans le bloc d'instructions de la boucle, la valeur de \emph{var} (le compilateur envoie un message d'erreur) et les modifications éventuelles lors de l'exécution de la boucle de \emph{debut}, \emph{fin} et \emph{pas} ne sont pas prises en compte. 

Il est imprudent de chercher à exploiter la valeur de \emph{var} après l'exécution de la boucle \texttt{do}. En effet, celle-ci ne prend pas nécessairement la valeur \emph{fin} comme on pourrait le penser a priori.
\end{attention}


\subsubsection{La boucle tant que}

La syntaxe générale est la suivante :
\begin{lstlisting}[language=Fortran]
do while (exp_log) 
    bloc     ! bloc d'instructions 
end do
\end{lstlisting}

Cette instruction permet de répéter le bloc d'instructions \emph{bloc} tant que l'expression logique \emph{exp\_log} est vraie. Si \emph{exp\_log} est fausse dès le début, le bloc n'est pas exécuté. Sinon, le bloc d'instructions doit modifier \emph{exp\_log} pour que la boucle puisse s'arrêter.

\subsubsection{Les instructions \emph{exit} et \emph{cycle}}

L'instruction \texttt{exit} permet de sortir d'une boucle de façon anticipée. Dans l'exemple suivant, les blocs \emph{bloc1} et \emph{bloc2} sont exécutés pour \emph{var} allant de \emph{debut} à \emph{fin} tant que l'expression logique \emph{exp\_log} est fausse. 

La boucle est interrompue si $var=fin$ ou si \emph{exp\_log} est vraie. Dans le premier cas on passe au \emph{bloc3}. Dans le second cas, \emph{bloc1} est exécuté mais pas \emph{bloc2}. Ensuite, on continue la boucle \texttt{do while} tant que \texttt{.not.fini} est vrai.

Comme on le voit sur cet exemple, lorsqu'une instruction \texttt{exit} appara\^{i}t dans une boucle qui est imbriquée dans une autre boucle, elle met fin à la boucle la plus interne.
\begin{lstlisting}[language=Fortran]
do while (.not.fini)
    do var = debut, fin 
        bloc1     ! bloc d'instructions 
        if (exp_log) exit
        bloc2     ! bloc d'instructions
    end do
    bloc3       ! bloc d'instructions
end do
\end{lstlisting}
Lorsque \emph{exp\_log} est vraie, on sort de la boucle \texttt{do var}


Dans l'exemple suivant, l'instruction \texttt{exit} s'applique à la boucle \texttt{do while} grâce à l'utilisation de l'identificateur \emph{boucle\_principale}. Ainsi, si \emph{exp\_log} est vraie, ni \emph{bloc2}, ni \emph{bloc3} ne sont exécutés et on sort de la boucle \texttt{do while}.
\begin{lstlisting}[language=Fortran]
do while (.not.fini)
         do var = debut, fin 
           bloc1     ! bloc d'instructions 
           if (exp_log) exit
           bloc2     ! bloc d'instructions
         end do
         bloc3       ! bloc d'instructions
end do
\end{lstlisting}
Lorsque \emph{exp\_log} est vraie, on sort de la boucle principale \texttt{do while}

L'instruction \texttt{cycle} permet de modifier le déroulement normal d'une boucle. Dans l'exemple suivant, \emph{bloc1} et \emph{bloc2} sont exécutés pour \emph{var} allant de \emph{debut} à \emph{fin} par pas de 1. 

Si l'expression logique \emph{exp\_log} est vraie, on passe à la valeur suivante de \emph{var} sans exécuter le \emph{bloc2}. Si \emph{exp\_log} est toujours vraie, seul \emph{bloc1} est exécuté.
\begin{lstlisting}[language=Fortran]
do var = debut, fin 
  bloc1      ! bloc d'instructions 
  if (exp_log) cycle
  bloc2       ! bloc d'instructions
end do
\end{lstlisting}

\section{Les tableaux}
\subsection{Déclaration des tableaux}
Un tableau est un ensemble ordonné d'éléments de même type. Chaque élément du tableau est repéré par un indice qui précise sa position au sein du tableau. Cet indice est entier. La déclaration des tableaux s'effectue comme suit :
\begin{lstlisting}[language=Fortran]
implicit none 
  
integer, parameter ::   min = -5       
integer, parameter ::   max = 12        
integer, parameter ::   nb = 10       
integer, parameter ::   nb1 = 5, nb2 = 3       
real, dimension (nb) ::           vect_1    ! tableau de rang 1 
integer, dimension (min:max) ::   vect_2    ! tableau de rang 1
real, dimension (50) ::            vect_3   ! tableau de rang 1
integer, dimension (nb1, nb2) ::  t         ! tableau de rang 2    
real, dimension (min:max, nb2) :: tab       ! tableau de rang 2 

[...]        ! bloc d'instructions executables
 
end
\end{lstlisting}

\begin{remarque}
Quand les bornes ne sont pas spécifiées, la borne inférieure est égale à 1. Dans l'un des exemples précédents, seul \emph{nb} est donné et les indices de \emph{vect\_1} vont de 1 à \emph{nb}. 

On peut aussi écrire : \texttt{real :: vect\_1(nb)}.
\end{remarque}

\begin{itemize}
\item  le nombre de dimensions est le \textbf{rang} du tableau (\emph{vect\_1} est de rang 1 et \emph{tab} est de rang 2). Le nombre maximum de dimensions est égal à 7.

\item  le nombre de valeurs possibles pour l'indice d'une dimension donnée est l'\textbf{étendue} du tableau suivant cette dimension (\emph{vect\_2} est d'étendue 18). L'indice est compris entre la \textbf{borne inférieure} (\emph{min} dans le cas de \emph{vect\_2}) et la \textbf{borne supérieure} (\emph{max} dans le cas de \emph{vect\_2}).

\item  le nombre d'éléments du tableau est la \textbf{taille} du tableau ; c'est donc le produit des étendues de chaque dimension (\emph{tab} est de taille 54).

\item  la liste des étendues est le \textbf{profil} du tableau (\emph{tab} est de profil (18, 3)).
\end{itemize}

\subsection{Les opérations relatives aux tableaux}

\subsubsection{Affectation collective}

Soit le tableau \emph{mat} de rang 3, si on désire affecter la valeur 1 à tous les éléments du tableau \emph{mat} on effectue, dans les principaux langages de programmation (\emph{Pascal}, \emph{C}, \emph{Fortran}), la suite d'instructions du programme suivant. En Fortran 90, il est possible d'obtenir le même résultat en écrivant l'instruction : \textbf{mat = 1}


\begin{lstlisting}[language=Fortran]
implicit none 
  
integer ::   i, j, k       
integer, dimension (5, -3:2, 10) ::   mat       ! tableau de rang 3 

do i = 1, 5 
  do j = -3, 2 
    do k = 1, 10 
      mat(i, j, k) = 1 
    end do 
  end do 
end do 

! est equivalent a 
mat = 1

! ou mieux
mat(:,:,:) = 1

end
\end{lstlisting}

\begin{remarque}
Par soucis de lisibilité, il est souhaitable d'expliciter les opérations sur tableaux en utilisant 
\begin{lstlisting}[language=Fortran]
mat(:,:,:) = 1
\end{lstlisting}
au lieu de 
\begin{lstlisting}[language=Fortran]
mat = 1
\end{lstlisting}
afin de pouvoir distinguer les opérations sur tableaux des opérations sur variables simples. Ça permet d'ailleurs de voir directement le nombre de dimensions du tableau.

\end{remarque}



\subsubsection{Les expressions tableaux}

On peut affecter une expression à chaque élément d'un tableau. Par exemple, les deux blocs d'instructions du programme suivant sont équivalents.

\begin{lstlisting}[language=Fortran]
implicit none 
  
integer :: i
integer, parameter ::         dim = 12

! tableaux de rang 1
integer, dimension (dim) ::   a,b
integer, dimension (dim) ::   som, prod, racine

! tableaux de type logique
logical, dimension (dim) ::   compare

do i = 1, dim 
  som(i) = a(i) + b(i) 
  prod(i) = a(i)*b(i)
  prod(i) = 2*prod(i) + 1 
  racine(i) = sqrt(real(a(i))) 
  if (som(i) < prod(i)) then 
    compare(i) = .true. 
  else 
    compare(i) = .false. 
  endif 
end do 

! En Fortran 90, les instructions precedentes
! se simplifient de la maniere suivante : 
    
! equivalent a : som = a + b
som(:) = a(:) + b(:)
prod(:) = a(:)*b(:)
prod(:) = 2*prod(:) + 1 

! Attention les elements de a sont entiers 
racine(:) = sqrt( real(a(:)) )
compare(:) = (som(:) < prod(:)) 

end
\end{lstlisting}

\subsubsection{Initialisation des tableaux à une dimension}

L'initialisation d'un tableau de rang 1 à $n$ éléments est possible en utilisant une liste de $n$ éléments définie par \emph{elem\_1,\ldots,elem\_n}. Le tableau correspondant s'écrit \texttt{(/elem\_1,\ldots,elem\_n/)}. 

Un tableau à plusieurs dimensions ne peut pas être initialisé directement. Il faut définir un tableau à une dimension et utiliser une fonction particulière qui n'est pas présentée dans ce cours : la fonction \texttt{reshape}.
 
\begin{lstlisting}[language=Fortran]
program initialisation

implicit none

integer ::                  i
integer, parameter ::       n = 5
integer, dimension(n) ::    tab1, tab2, t         ! tableaux de rang 1
integer, dimension(n) ::    tab3 = (/1,2,3,4,0/)
real, dimension(0:9) ::     angle

tab1(1) = 3 ; tab1(2) = 5 ; tab1(3) = -2 ; tab1(4) = 4 ; tab1(5) = 202

tab2 = (/ 3, 5, -2, 4, 202/)

! les affectations suivantes sont equivalentes
do i = 0, 90, 10
  angle(i/10) = i*0.5
end do

angle = (/(i*0.5, i=0, 90, 10)/)                ! boucle implicite

end
\end{lstlisting}

\subsubsection{Les sections de tableau}

\emph{Fortran 90} introduit une notion nouvelle par rapport aux langages tels 
que \emph{C} ou \emph{Pascal} qui est la section de tableau. 
L'écriture générale d'une section de tableau est la suivante :
\begin{lstlisting}[language=Fortran]
tab(borne_inf : borne_sup : pas [,...])
\end{lstlisting}


\begin{itemize}
\item \emph{tab} est le nom d'un tableau,
\item \emph{borne\_inf} est la borne inférieure de la section de tableau (c'est la borne inférieure de \emph{tab} si elle est omise), 
\item \emph{borne\_sup} est la borne supérieure de la section de tableau (c'est la borne supérieure de \emph{tab} si elle est omise),
\item \emph{pas} est le pas d'incrémentation (1 par défaut ; si le pas est négatif, la variation d'indice est rétrograde de \emph{borne\_sup} à \emph{borne\_inf}.
\end{itemize}

\begin{figure}[htb]
\centering
\includegraphics[width=0.65\linewidth]{figure/sections_de_tableaux.pdf}
\caption{Représentation de différentes sections de tableaux afin de montrer les possibilités de sélections.}
\end{figure}

Dans le programme suivant,
\begin{lstlisting}[language=Fortran]
integer, dimension (n) ::   w
integer, dimension (p) ::   v

v(:) = (/(i,i=1,p)/)       ! boucle implicite

! EXEMPLE 1

w(2:4) = v(7:9)
\end{lstlisting}
les valeurs  \emph{v(7)}, \emph{v(8)}, \emph{v(9)} du tableau \emph{v} sont affectées respectivement aux éléments \emph{w(2)}, \emph{w(3)} et \emph{w(4)} du tableau \emph{w}. Ainsi, la notation \texttt{w(i:j)} signifie que l'on s'intéresse aux éléments \emph{w(i), w(i+1), \ldots, w(j)} ($j>i$). 

\begin{remarque}
Si on écrit \texttt{w(3:1) = 1}, aucune affectation ne sera effectuée.
\end{remarque}

Dans le second exemple, on remarque qu'il y a un recoupement, c'est à dire que le même terme apparait à gauche et à droite du signe égal puisqu'on a les deux affectations \og simultanées\fg :
\begin{align*}
v(2) &= (v(1)+v(3))/2\\
v(3) &= (v(2)+v(4))/2
\end{align*}
Que vaut $v(2)$ dans la seconde affectation ?! 

\begin{important}
La règle adoptée par \emph{Fortran 90} est la suivante : la valeur d'une expression de type tableau est entièrement évaluée avant d'être affectée. 
\end{important}

\begin{lstlisting}[language=Fortran]
integer, dimension (n) ::   w
integer, dimension (p) ::   v, v1

v(2:9) = (v(1:8) + v(3:10))/2

! est equivalent a
do i = 1, p
  v1(i) = v(i)
end do
do i = 2, 9
  v(i) = (v1(i-1) + v1(i+1))/2
end do
\end{lstlisting}

Dans cet exemple, si on n'utilise pas les sections de tableau, on remarque qu'il est nécessaire d'utiliser un tableau tampon \emph{v1} pour effectuer les calculs intermédiaires. 

\subsubsection{Les fonctions portant sur des tableaux}

Il existe en \emph{Fortran 90} des fonctions spécifiques aux tableaux. Les plus usuelles sont \texttt{sum} qui fournit la somme des éléments d'un tableau, \texttt{maxval} qui donne la valeur maximale d'un tableau, \texttt{minval} qui donne la valeur minimale et \texttt{product} qui donne le produits des éléments. Les fonctions \texttt{dot\_product} et \texttt{matmul} permettent d'obtenir respectivement le produit scalaire et le produit matriciel de deux tableaux.

\begin{exemple}
Soit $A$ un tableau à $m$ ligne(s) et $n$ colonne(s). On cherche la valeur maximale de l'ensemble formé par les éléments se trouvant à la ligne $j$ pour les colonnes allant de $i$ à $n$. Il suffira pour cela d'écrire l'instruction suivante :
\begin{lstlisting}[language=Fortran]
maxval(A(j,i:n))
\end{lstlisting}

\bigskip

Soit $A$ une matrice de rang 2 à $n$ colonnes. L'instruction 
\begin{lstlisting}[language=Fortran]
sum(A, dim=1)
\end{lstlisting}
permet d'obtenir un tableau de rang 1 et d'étendue $n$ dont chaque élément $i$ est le résultat de la somme des éléments de la colonne $i$ de $A$.
\end{exemple}


\subsection{L'instruction \emph{where}}

Cette instruction permet de traiter les éléments d'un tableau vérifiant une certaine condition. La syntaxe est la suivante :

\begin{lstlisting}[language=Fortran]
where (inst_log_tab)
  bloc1 
[elsewhere 
  bloc2 
] 
end where
\end{lstlisting}
\emph{inst\_log\_tab} est une instruction logique portant sur les éléments d'un tableau. Lorsque cette condition est vérifiée, le bloc d'instructions \emph{bloc1} est exécuté, sinon le bloc d'instructions \emph{bloc2} est exécuté. 

Lorsque \emph{bloc1} ne contient qu'une seule instruction et que \emph{bloc2} est absent, on peut utiliser une forme simplifiée identique au \texttt{if} logique. 

Ainsi, dans l'exemple suivant, tous les éléments négatifs du tableau $A$ sont mis à zéro : 
\begin{lstlisting}[language=Fortran]
where (A < 0) A = 0.0
\end{lstlisting}

\subsection{Les tableaux dynamiques}

Quand on ne connait pas à l'avance la taille des tableaux que l'on souhaite utiliser, on peut "surdimensionner" le tableaux en question au moment de la declaration mais la méthode la plus élégante consiste à utiliser les tableaux dynamiques (tableaux à allocation différée). L'allocation sera effectuée lorsque les étendues du tableau seront connues (après lecture dans un fichier, au clavier ou après des calculs).

\bigskip

La déclaration d'un tableau dynamique s'effectue en précisant le 
rang du tableau et en utilisant l'attribut \texttt{allocatable} 
(allouable). 
\begin{lstlisting}[language=Fortran]
! declaration d'un tableau dynamique d'entiers de rang 2 
real, dimension(:,:), allocatable :: matrice
\end{lstlisting}

\bigskip

L'allocation d'un emplacement se fait en utilisant l'instruction \texttt{allocate} en précisant chaque étendue :
\begin{lstlisting}[language=Fortran]
! declaration d'un tableau dynamique d'entiers de rang 2 
real, dimension(:,:), allocatable :: matrice
integer :: n, m, verif

[...]                         ! bloc d'instructions executables

! lecture au clavier des etendues
read*, n                      ! suivant la premiere dimension
read*, m                      ! suivant la seconde dimension

allocate(matrice(n,m))
\end{lstlisting}

\begin{remarque}
Pour vérifier que l'allocation (ou la désallocation) s'est bien effectuée, on peut utiliser l'option \texttt{stat}. 
\begin{lstlisting}[language=Fortran]
allocate(matrice(n,m), stat=verif)
\end{lstlisting}
\emph{verif} est une variable entière. Si \texttt{verif = 0}, l'allocation s'est bien effectuée, sinon une erreur s'est produite. 
\end{remarque}

Lorsqu'un tableau dynamique devient inutile, il est recommandé de libérer la place allouée à ce tableau. Pour cela, on utilise l'instruction \texttt{deallocate} (désallouer).
\begin{lstlisting}[language=Fortran]
deallocate(matrice)           ! liberation
\end{lstlisting}

\bigskip

Il est possible de transmettre un tableau dynamique en argument d'une procédure sous certaines conditions : 
\begin{itemize}
\item Le tableau dynamique devra être alloué et libéré dans le programme principal. 
\item Le programme principal doit contenir l'interface de la procédure. Cette condition n'est pas obligatoire si on utilise un module! (voir par exemple le programme \emph{tableau\_dynamique}).
\end{itemize}
% Il y a un exemple par 43 du tutoriel de michel qui donne un exemple de ça. 
%TODO 

\section{Les Modules}

\begin{figure}[htb]
\centering
\includegraphics[width=0.65\linewidth]{figure/structure_programme.pdf}
\caption{Structure générale d'un programme Fortran 90}\label{fig:structure_programme}
\end{figure}

\reffig{fig:structure_programme} présente la structure générale d'un programme \emph{Fortran 90}. Nous allons voir qu'un programme principal peut aussi faire des appels à un ou plusieurs modules. 

\begin{definition}
Le module se présente comme une unité de programme autonome permettant de mettre des informations en commun avec d'autres unités de programmes. 
\end{definition}


Ce programme est généralement écrit dans un fichier différent du fichier contenant le programme principal. Le module est compilé indépendamment des autres unités de programme mais ne peut pas être exécuté seul. Comme le montre \reffig{fig:structure_programme}, les modules peuvent contenir des procédures (sous-programmes et fonctions), des blocs de déclarations et des données. 

Le module permet de fiabiliser les programmes en évitant la duplication des déclarations et des affectations utilisées par plusieurs unités de programme puisqu'il donne l'accès de son contenu à toutes les unités de programme qui en font l'appel.

Ils permettent : 
\begin{itemize}
\item Une écriture des sources plus simples : en particulier ils évitent d'avoir à écrire des blocs \texttt{interface} qui sont assez lourds quand ils doivent être souvent répétés
\item de remplacer avantageusement la notion de \texttt{COMMON}
\item D'accéder à toutes les ressources du \emph{Fortran 90} avec un maximum d'efficacité et de cohérence : gestion dynamique de la mémoire, pointeurs, généricité, surdéfinition des opérateurs, encapsulation\dots
\end{itemize}

\begin{attention}
Les unités \texttt{module} doivent être compilés \emph{avant} de pouvoir être utilisées. Si le fichier source est unique, elles doivent être placées en tête.
\end{attention}


\subsection{Struture générale}
Le module peut contenir un ensemble de déclarations et d'affectations et/ou une ou plusieurs procédure(s). Dans ce dernier cas, les procédures doivent être précédées par l'instruction \texttt{contains}. Un module commence par l'instruction \texttt{module} suivi du nom du module et se termine obligatoirement par \texttt{end module}.

\begin{lstlisting}[language=Fortran]
module nom_module
   
   implicit none 
   [...]         ! bloc de declarations 

   contains      ! obligatoire si suivi de procedures
   
   [...]         ! suite de procedures
 
end module nom_module
\end{lstlisting}

\subsection{Appel des modules depuis un programme principal}
L'utilisation des modules est très simple ; depuis le programme principal, l'appel du module se fait par l'instruction \texttt{use} suivi du nom du module. Il faut noter que le nom du module doit être différent de celui du programme principal. L'instruction \texttt{use} doit précéder toute autre déclaration.

\begin{lstlisting}[language=Fortran]
program utilisation_module

use nom_module 
use module_constantes

implicit none 
[...]     ! bloc de declarations

[call...
 call...] ! appels des procedures contenues dans le module nom_module
[...]     ! bloc d'instructions executables
 
end 
\end{lstlisting}

\begin{remarque}
Un module ne doit pas se référencer lui-même, même de manière indirecte. Par exemple, si le module \emph{module1} contient \texttt{use module2}, ce dernier ne doit pas contenir l'instruction \texttt{use module1}.
\end{remarque}

\subsection{Accès à tout ou partie d'un module}

Une unité de programme qui appelle un module (via l'instruction \texttt{use}) à accès à toutes les entités de ce module (variables, procédures). Il est possible cependant de contrôler l'accès à ces entités pour empêcher les conflits entre différentes unités de programme.

\bigskip

\begin{attention}
Lorsqu'une unité de programme appelle un ou plusieurs modules, il peut y avoir un conflit entre les identificateurs (noms des variables et des procédures) de l'unité de programme et des modules. Si l'on ne souhaite pas modifier les identificateurs des modules (ce qui peut être laborieux si le module est long), il est possible de renommer ces identificateurs lors de l'appel des modules à partir de l'unité de programme.
\begin{lstlisting}[language=Fortran]
use nom_module, nom_id_local => nom_id_module
\end{lstlisting}

\begin{itemize}
\item \emph{nom\_module} est le nom du module,
\item \emph{nom\_id\_local} est le nom attribué à l'identificateur 
dans l'unité de programme qui appelle le module,
\item \emph{nom\_id\_module} est le nom de l'identificateur public du 
module que l'on souhaite renommer.
\end{itemize}
\end{attention}


\begin{exemple}
\begin{lstlisting}[language=Fortran]
use module_constantes, k_bol => k
\end{lstlisting}
va permettre d'utiliser la constante $k$ du module \emph{module\_constantes} sous le nom $k_\text{bol}$ dans le programme, afin de ne pas rentrer en conflit avec une variable $k$ qui existe aussi dans le programme.
\end{exemple}


\subsubsection{Protection interne}
La première méthode pour contrôler l'accès à un module consiste à protéger certaines entités. Pour cela on utilise les instructions \texttt{private} et \texttt{public}. Par défaut, l'option d'accès au module est \emph{public}. Toutes les instructions du module se trouvant après l'instruction \texttt{private} seront d'accès privé (et donc inaccessible par le programme qui appelle le module). Il est possible aussi d'ajouter l'attribut \texttt{private} lors de la déclaration d'une variable pour protéger son accès.

\begin{lstlisting}[language=Fortran]
module module_atmosphere

use module_constantes, only : k, Na

real, private :: T = 300., &     ! temperature [K]
                 m = 28.0e-3, &  ! masse mol. moy. [gmol-1]
                 g = 9.81, &     ! pesanteur [ms-2]
                 Po = 1.01325e5  ! pression standard [Pa]

contains

function pression(z)

  real :: pression          ! pression a l'altitude z [Pa]
  real, intent(in) :: z     ! altitude [km]
  real :: h                 ! hauteur d'echelle [km]

  h = (k*T*Na)/(m*g)/1.0e3
  pression = Po*exp(-z/h)

end function pression

end module module_atmosphere
\end{lstlisting}

Et on accède au module de la façon suivante : 
\begin{lstlisting}[language=Fortran]
program acces

use module_atmosphere

implicit none

real :: p, &    ! pression [Pa]
        z       ! altitude [km]

z = 10
p = pression(z)

print*, p, g, h

end
\end{lstlisting}

Les variables \emph{T}, \emph{m}, \emph{g} et \emph{Po} ne sont pas accessibles par le programme \emph{acces} malgré l'appel du module \emph{module\_atmosphere}. Elles ont, en effet, l'attribut \texttt{private} dans \emph{module\_atmosphere}. La variable \emph{h} de la fonction \emph{pression} n'est pas en conflit avec la variable \emph{h} de \emph{module\_constantes} grâce à la restriction d'accès via l'instruction \texttt{only}.

\subsubsection{Protection externe}
La seconde méthode de contrôle d'accès entre le module et l'unité de programme qui l'appelle consiste à restreindre l'accès à certaines entités depuis l'unité de programme. Cette restriction s'effectue en utilisant l'attribut \texttt{only} lors de l'appel du module (voir le module \emph{module\_atmosphere}).
\begin{lstlisting}[language=Fortran]
use nom_module, only : liste_entites
\end{lstlisting}
où \emph{liste\_entites} est la liste des variables et procédures auxquelles on autorise l'accès lors de cet appel.



\subsection{Partage de données et variables}
Les modules peuvent être utilisés pour déclarer des variables susceptibles d'être communes à de nombreux programmes. Par exemple, un physicien est amené à utiliser, dans l'ensemble de ses programmes, les différentes constantes de la Physique. Plutôt que de déclarer ces constantes dans chaque programme, il suffit d'utiliser un module approprié dans lequel elles seront affectées une fois pour toute.

\begin{footnotesize}
\begin{lstlisting}[language=Fortran]
module module_constantes

implicit none

! Constantes de la physique en unite S.I.

real, parameter :: c = 2.99792458e8 ,  &        ! vitesse de la lumiere [ms-1]
                   G = 6.6720e-11,     &        ! constante de la gravitation [Nm2kg-2]
                   h = 6.626176e-34,   &        ! constante de planck [JHz-1]
                   k = 1.380662e-23,   &        ! constante de Boltzmann [JK-1]
                   Na = 6.022045e23,   &        ! constante d'Avogadro [mol-1]
                   Rg = 8.3145                  ! constante des gaz parfaits [Jmol-1K-1]
 
end module module_constantes
\end{lstlisting}
\end{footnotesize}

\section{Les Procédures (fonction et subroutine)}
Il existe deux types de procédures~: les sous-programmes et les fonctions (respectivement \texttt{subroutine} et \texttt{function} en anglais). Nous étudierons les fonctions plus loin dans le chapitre. Parmi les procédures, on distingue les procé\-dures externes des procédures internes.

\bigskip

Les sous-programmes externes (\texttt{subroutine} ou \texttt{fonction}) sont des blocs de code en dehors du programme principal, soit après son instruction \texttt{end}, soit dans un fichier séparé qu'il faudra aussi compiler. 
\begin{lstlisting}[language=Fortran]
program nom_program
 
implicit none 
[...]         ! bloc de declaration
 
[...]         ! bloc d'instructions executables
 
call nom(liste_arguments)         ! appel du sous-programme
 
[...]         ! bloc d'instructions executables
 
end  

subroutine nom(liste_arguments)

implicit none 
[...]         ! bloc de declaration (arguments et variables locales)

[...]         ! bloc d'instructions executables
 
end subroutine nom 
\end{lstlisting}


Les sous-programmes internes (\texttt{subroutine} ou \texttt{fonction}) sont des blocs de code qui vont être dans le corps du programme, à la suite de l'instruction \texttt{contains} et avant l'instruction \texttt{end}.
\begin{lstlisting}[language=Fortran]
program nom_program
 
implicit none 
[...]         ! bloc de declaration
 
[...]         ! bloc d'instructions executables 
call nom(liste_arguments)         ! appel du sous-programme 
[...]         ! bloc d'instructions executables 

contains 
subroutine nom1(liste_arguments) 
[...]         ! bloc de declaration 
[...]         ! bloc d'instructions executables 
end subroutine nom1 

subroutine nom2(liste_arguments) 
[...]         ! bloc de declaration 
[...]         ! bloc d'instructions executables 
end subroutine nom2 

end
\end{lstlisting}

Dans le cas des procédures externes, on est en présence de domaines indépendants qui ne peuvent communiquer que par le biais des arguments. 

Dans le cas des procédures internes, la procédure a accès à toutes les variables définies par son hôte. Ces variables sont dites \emph{globales} et n'ont plus besoin d'être transmises en arguments. En revanche, toutes les variables déclarées dans la procédure interne sont locales à la procédure. 

Ainsi, la déclaration de deux variables, l'une dans le programme hôte et l'autre dans la procédure interne avec le même nom provoque la création de deux variables différentes (bien qu'ayant le même nom!). Bien que pouvant paraître attrayante, cette méthode d'utilisation des procédures est à utiliser avec circonspection. En effet, l'utilisation dans le programme principal et le sous-programme interne d'un même nom pour 2 variables a priori différentes, risque de provoquer des erreurs de programmation. 


\begin{attention}
Il est important de noter que les procédures internes ne peuvent être utilisées que par l'hôte qui les contiennent. 
\end{attention}

\subsection{fonctions}
En \emph{Fortran 90}, les fonctions peuvent retourner n'importe quel type valide (tableau, type dérivé)



%TODO parler des types dérivés, des fonctions et des subroutine pour présenter chacun des deux.
\section{Avancé}
\subsection{les pointeurs}
Un pointeur, ce n'est ni plus ni moins qu'une variable qui contient une adresse mémoire. 

Ceci étant dit, on définit différents types de pointeurs, selon la nature des objets vers lesquels on pointe. L'utilité d'une telle chose est de pouvoir faire de l'arithmétique avec les pointeurs, vu que l'on connait la taille mémoire de chaque objet qu'on manipule. 

\begin{figure}[htb]
\centering
\includegraphics[width=0.65\linewidth]{figure/pointeurs.pdf}
\caption{Représentation schématique du fonctionnement d'un pointeur avec représentation de la mémoire. Les numéros pour les cases mémoires ne représentent pas la réalité, c'est juste pour montrer comment on fait référence à une case mémoire. L'idée est de montrer qu'en manipulant des adresses au lieu de manipuler les contenus, on peut faire des choses beaucoup plus puissantes.}
\end{figure}

%TODO lire des trucs sur les pointeurs, les types dérivés et les procédures récursives.

\end{document}